<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover">
    <title>Gem Getter Pro</title>
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
	
	<!-- Link to manifest for Android/PWA -->
	<link rel="manifest" href="/manifest.json">

	<!-- iOS-specific icon (Apple Touch Icon) -->
	<link rel="apple-touch-icon" href="/icon-ios-touch.png">
	
    <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Covered+By+Your+Grace&family=Gamja+Flower&family=Patrick+Hand&family=Single+Day&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">    
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8/hammer.min.js"></script>
    <style>

        /* Add to the top of your CSS */

/* Lock html/body to full viewport, no scroll */
html, body {
  height: 100%; /* Fallback for older browsers */
  min-height: 100svh; /* Use svh (small viewport) on mobile to avoid bar-induced overflow */
  margin: 0;
  padding: 0;
  overflow: hidden; /* Disable all overflow/scroll (x and y) */
  touch-action: pan-x; /* Allow horizontal touch (for swipes), block vertical */
}

/* Prevent pull-to-refresh/bounce on mobile */
body {
  overscroll-behavior-y: none; /* Block vertical overscroll */
}

/* Ensure game-container fills exactly, no extra space */
#game-container {
  height: 100svh; /* Match body, use svh for consistency */
  min-height: 100svh;
  overflow: hidden; /* Redundant but ensures no child overflow */
}

/* For sections/wrappers: Clamp heights to prevent internal overflow */
.section, .section-image-wrapper {
  height: 100svh; /* Switch to svh if dvh causes issues; test both */
  max-height: 100svh;
  overflow: hidden;
}

/* Fixed arrows: Ensure they stay visible over everything */
.nav-button {
  position: fixed !important; /* Override any absolute */
  z-index: 100; /* High to stay above content */
  /* Existing styles remain */
}

body {
	margin: 0;
	font-family: Arial, sans-serif;
	min-height: 100dvh;
	overflow-x: hidden;
	background-color: #f0f0f0;
}

#game-container {
	position: relative;
	width: 300%;
	height: 100dvh;
	display: flex;
	transition: transform 0.5s ease;
	transform: translateX(-100vw);
}

#opening-menu {
  position:relative;
	display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100dvh;
  background: #fff;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  z-index: 100;
}

.menu-button {
	font-family: 'Bebas Neue', sans-serif;
  letter-spacing: 0.1dvh;
  height: 7dvh;
  width: 28dvh;
  font-size: 3.5dvh;
  background-color: #333;
  color: white;
  border: none;
  border-radius: 0.5dvh;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: .5dvh;
  margin: 1dvh;
  transition: background-color 0.3s ease, box-shadow 0.3s ease;
	text-decoration: none;
	transform:scale(1);
}

.menu-button-white {
	font-family: 'Bebas Neue', sans-serif;
  letter-spacing: 0.1dvh;
  height: 7dvh;
  width: 28dvh;
  font-size: 3.5dvh;
  background-color: #ededed;
  color: black;
  border: none;
  border-radius: 0.5dvh;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 1dvh 2dvh;
  margin: 1dvh;
  transition: background-color 0.3s ease, box-shadow 0.3s ease;
	transform:scale(1);
}


.menu-button:hover {
  background-color: #555;
  box-shadow: 0 0 0.5dvh rgba(255, 255, 255, 0.3);
	transform:scale(1.1);
}

.menu-button-white:hover {
  background-color: #f7f7f7;
  box-shadow: 0 0 0.5dvh rgba(255, 255, 255, 0.3);
	transform:scale(1.1);
}

#free-play-button {
	margin-top:6dvh;
}

#game-logo {
  margin-top:5dvh;
	height: 30dvh;
}


#daily-challenge-timer {
  font-family: 'Bebas Neue', sans-serif;
  letter-spacing: 0.1dvh;
  font-size: 3dvh;
  color: #333;
  border: none;
  border-radius: 0.5dvh;
  display: flex;
  justify-content: center;
  align-items: center;
  width: 30dvh; /* Slightly wider to fit HH:MM:SS */
  height: 3dvh;
  opacity: 1; /* Ensure visibility */
	margin-bottom:3dvh;
}

#resume-button {
  font-family: 'Bebas Neue', sans-serif;
  letter-spacing: 0.1dvh;
  height: 8dvh;
  width: 30dvh;
  font-size: 4dvh;
  background-color: #333;
  color: white;
  border: none;
  border-radius: 0.5dvh;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 1dvh 2dvh;
  margin: 10px;
  transition: background-color 0.3s ease, box-shadow 0.3s ease;
}

#resume-button:hover {
  background-color: #555;
  box-shadow: 0 0 0.5dvh rgba(255, 255, 255, 0.3);
}

#free-play-submenu {
	position:absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100dvh;
  background: #fff;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 101;
}

.back-button {
  position: absolute;
  top: 10px;
  left: 10px;
  width: 6dvh;
  height: 6dvh;
  font-size: 3dvh;
  background-color: #333;
  color: white;
  border: none;
  border-radius: 0.5dvh;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
  transition: background-color 0.3s ease, box-shadow 0.3s ease;
	transform: scale(1);
}

.back-button:hover {
  background-color: #555;
  box-shadow: 0 0 0.5dvh rgba(255, 255, 255, 0.3);
	transform: scale(1.2);
}

.arrow-icon {
  font-weight: bold;
}

.submenu-content {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    width: 100vw;
    height: 100svh;
}

.submenu-content h2 {
  font-family: 'Bebas Neue', sans-serif;
  font-size: 4dvh;
  color: #333;
  margin: 10px 0;
}

.submenu-content h2 {
	font-family: 'Bebas Neue', sans-serif;
  font-size: 4dvh;
  color: #333;
  margin: 0.5dvh 0; /* Reduced from 10px to bring text closer to buttons */
}

.video-container {
    width: 80vw;
    max-width: 600px;
    margin: 2dvh auto;
}

.clearly-sharp-logo {
    height: 25dvh;
    margin: 2dvh auto;
}

.clearly-sharp-text {
    font-family: 'Montserrat', sans-serif;
    font-size: 2.5dvh;
    color: black;
    text-align: center;
    max-width: 80vw;
    margin: 2dvh auto;
	  padding-bottom: 4dvh;
}

.dig-sheet-buttons {
  display: flex;
  flex-direction: column; /* Stack rows vertically */
  align-items: center; /* Center rows horizontally */
  gap: 1dvh; /* Space between rows */
  margin-bottom: 6dvh;
}

.roll-sheet-buttons {
  display: flex;
  gap: 1dvh;
  justify-content: center;
  margin-bottom: 10dvh;
}

.dig-sheet-row {
  display: flex;
  flex-direction: row; /* Ensure buttons align horizontally within each row */
  gap: 1dvh; /* Space between buttons */
  justify-content: center; /* Center buttons in row */
}

.sheet-button {
  width: 6dvh;
  height: 6dvh;
  background-color: transparent;
  border: none;
  border-radius: 0.5dvh;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 0;
  transition: transform 0.3s ease;
  position: relative; /* Needed for pseudo-element positioning */
}

.sheet-button img {
  width: 100%;
  height: 100%;
  object-fit: contain;
  border-radius: 0.5dvh;
  transition: transform 0.3s ease;
}

.sheet-button.selected {
  transform: scale(1.25);
  animation: subtle-rotate 2s ease-in-out infinite;
}

.sheet-button:hover:not(.selected)::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(255, 255, 255, 0.2); /* White 30% opacity overlay */
  border-radius: 0.5dvh;
}

@keyframes subtle-rotate {
  0% { transform: scale(1.25) rotate(-5deg); }
  50% { transform: scale(1.25) rotate(5deg); }
  100% { transform: scale(1.25) rotate(-5deg); }
}

.submenu-actions {
  display: flex;
  flex-direction: column;
  gap: 1dvh;
}

#play-button:disabled {
  background-color: #ccc;
  cursor: not-allowed;
}

.section {
	width: 100vw;
	height: 100dvh;
	box-sizing: border-box;
	color: white;
	display: flex;
	flex-direction: column;
	justify-content: center;
	align-items: center;
	position: relative;
	overflow: hidden;
	background-color: white;
}
.section-image-wrapper {
	position: relative;
	width: 100vw; /* Explicitly match section width */
	height: 100cqh; /* Match section height */
	display: flex;
	justify-content: center;
	align-items: center;
	container-type:size;
}
.section-image {
	max-width: 100%;
	max-height: 100%;
	width: auto; /* Allow natural width up to max */
	height: auto; /* Allow natural height up to max */
	object-fit: contain;
	position: relative; /* Remove any absolute positioning conflicts */
}
#dig-roll {
	position: relative;
	width: 100vw;
	height: 100dvh;
}

#dig-sheet {
	position: relative;
	height:100%;
	width:100%;
  height: 75dvh;
  overflow: hidden;
	background-image: url('https://i.imgur.com/3biwDEh.png');
	background-size: contain;
	background-repeat: no-repeat;
	background-position: center;
}

#dig-sheet.dig-sheet-a {
  background-image: url('https://i.imgur.com/3biwDEh.png');
}
#dig-sheet.dig-sheet-b {
  background-image: url('https://i.imgur.com/AwZ16ox.png');
}

#dig-sheet-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 3;
  pointer-events: none;
	container-type:size;
	container-name:overlay;
}
#dig-sheet-overlay img {
  width: 100%;
  height: 100%;
  object-fit: contain; /* Preserve aspect ratio */
}

#dig-sheet-switcher {
  position: absolute;
  width: 6cqh;
  height: 6cqh;
  cursor: pointer;
  z-index: 40;
	transform:translateX(-50%);
  top: 11cqh;
  left: calc(50% - 29.8cqh);
	pointer-events: auto;
	background-color:white;
	opacity:0%;
}

#dig-sheet-switcher:hover {
	opacity:30%;
}

#roll-sheet-switcher {
  position: absolute;
  top: 4.6dvh; /* Top of roll sheet, adjust if needed */
  left: calc(50% - .7dvh);
  transform: translateX(-50%); /* Center horizontally */
  width: 4.3dvh; /* Example size, adjust to fit */
  height: 4.3dvh;
  background: white;
	opacity:0%;
  border-radius: 5px;
  cursor: pointer;
  z-index: 20; /* Above roll sheet elements */
}

#roll-sheet-switcher:hover {
  opacity:30%;
}

#cross-off-container {
	position:absolute;
	transform:translate(-50%, -50%);
	top:50%;
	left:50%;
	width: 75.05cqh;
	height:100cqh;
	z-index:40;
	container-type:size;
}

.grid-placeholder {
  height: 41.8dvh;
  width: 41.8dvh;
  top: 17.1dvh;
  left: calc(50% + 3.2dvh);
  transform: translateX(-50%);
  z-index: 2;
  position: absolute;
  overflow: visible;
}

#roll-area {
	flex: 25%;
	width: 100%;
	display: flex;
	justify-content: space-between;
}
.roll-column {
	display: flex;
	position: relative;
	background-color: white;
	height: 100%;
}
.roll-column-left {
	flex: 1;
	background-color: white;
}
.roll-column-middle {
	flex: 0 0 18.76dvh;
	background-color: white;
	justify-content: center;
}
.roll-column-right {
	flex: 1;
	background-color: white;
}
.cross-off-clicker {
	width: 5.5cqh;
	height: 5.5cqh;
	position: absolute;
	transform: translate(-50%, -50%) rotate(-45deg);
	z-index: 20;
	display: flex;
	justify-content: flex-start;
	align-items: center;
	pointer-events: none;
}
.oil-ng-cross-off-clicker {
	width: 4.7cqh;
	height: 4.7cqh;
	border-radius: 4cqh;
	position: absolute;
	transform: rotate(-45deg);
	z-index: 20;
	display: flex;
	justify-content: flex-start;
	align-items: center;
	pointer-events: auto;
	cursor: pointer;
	opacity: 1 !important;
}
.cross-off-round {
	width: 3.4cqh;
	height: 3.4cqh;
	position: absolute;
	transform:translate(-50%, -50%) rotate(-45deg);
	z-index: 20;
	display: flex;
	justify-content: flex-start;
	align-items: center;
	pointer-events: none;
}
.line-draw {
	container: overlay;
	width: 0;
	height: .7cqh;
	background-color: black;
	border-radius: 1cqh;
	transition: width 100ms ease-out;
	transform-origin: left;
}
.cross-off-clicker.crossed-off .line-draw,
.oil-ng-cross-off-clicker.crossed-off .line-draw,
.cross-off-round.crossed-off .line-draw {
	width: 100%;
}


.die {
	width: 7dvh;
	height: 7dvh;
	position: absolute;
	display: flex;
	background-size: cover;
	background-repeat: no-repeat;
	z-index: 4;
}
.die.green {
	background-image: url("https://i.imgur.com/gDedEHi.png");
	left: calc(50% - 8dvh);
	top: 5dvh;
}
.die.white {
	background-image: url("https://i.imgur.com/nZjAHjr.png");
	left: calc(50% + 1dvh);
	top: 5dvh;
}
.pip {
	position: absolute;
	width: 1.2dvh;
	height: 1.2dvh;
	background-color: #000;
	border-radius: 50%;
	display: none;
}
.die.green .pip {
	background-color: #fff;
	border: 1px solid black;
}
.die[data-value="1"] .pip:nth-child(1) {
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	display: block;
}
.die[data-value="2"] .pip:nth-child(1) {
	top: 15%;
	left: 15%;
	display: block;
}
.die[data-value="2"] .pip:nth-child(2) {
	bottom: 15%;
	right: 15%;
	display: block;
}
.die[data-value="3"] .pip:nth-child(1) {
	top: 15%;
	left: 15%;
	display: block;
}
.die[data-value="3"] .pip:nth-child(2) {
	bottom: 15%;
	right: 15%;
	display: block;
}
.die[data-value="3"] .pip:nth-child(3) {
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	display: block;
}
.die[data-value="4"] .pip:nth-child(1) {
	top: 15%;
	left: 15%;
	display: block;
}
.die[data-value="4"] .pip:nth-child(2) {
	top: 15%;
	right: 15%;
	display: block;
}
.die[data-value="4"] .pip:nth-child(3) {
	bottom: 15%;
	left: 15%;
	display: block;
}
.die[data-value="4"] .pip:nth-child(4) {
	bottom: 15%;
	right: 15%;
	display: block;
}
.die[data-value="5"] .pip:nth-child(1) {
	top: 15%;
	left: 15%;
	display: block;
}
.die[data-value="5"] .pip:nth-child(2) {
	top: 15%;
	right: 15%;
	display: block;
}
.die[data-value="5"] .pip:nth-child(3) {
	bottom: 15%;
	left: 15%;
	display: block;
}
.die[data-value="5"] .pip:nth-child(4) {
	bottom: 15%;
	right: 15%;
	display: block;
}
.die[data-value="5"] .pip:nth-child(5) {
	top: 50%;
	left: 50%;
	transform: translate(-50%, -50%);
	display: block;
}
.die[data-value="6"] .pip:nth-child(1) {
	top: 15%;
	left: 15%;
	display: block;
}
.die[data-value="6"] .pip:nth-child(2) {
	top: 50%;
	left: 15%;
	transform: translateY(-50%);
	display: block;
}
.die[data-value="6"] .pip:nth-child(3) {
	bottom: 15%;
	left: 15%;
	display: block;
}
.die[data-value="6"] .pip:nth-child(4) {
	top: 15%;
	right: 15%;
	display: block;
}
.die[data-value="6"] .pip:nth-child(5) {
	top: 50%;
	right: 15%;
	transform: translateY(-50%);
	display: block;
}
.die[data-value="6"] .pip:nth-child(6) {
	bottom: 15%;
	right: 15%;
	display: block;
}

.dice-container {
	position: relative;
	width: 100%;
	height: 60px;
}
.image-container {
	position: absolute;
	bottom: -100%;
	height: 25dvh;
	width: 100%;
	transition: bottom 0.25s ease-in-out;
}
.image-container.show {
	bottom: 0;
}
.image-container.hide {
	bottom: -100%;
}
#green-image img {
	position: absolute;
	right: 0dvh;
	max-width: 100%;
	max-height: 25dvh;
	object-fit: contain;
}
#white-image img {
	position: absolute;
	left: 0dvh;
	max-width: 100%;
	max-height: 25dvh;
	object-fit: contain;
}
@keyframes jumpAndSpin {
	0% {
		transform: translateY(0) rotate(0deg);
	}
	50% {
		transform: translateY(-50px) rotate(360deg);
	}
	100% {
		transform: translateY(0) rotate(720deg);
	}
}
.jumping {
	animation: jumpAndSpin 0.5s ease;
}

#undo-button {
  position: absolute;
  transform: translateX(-100%) scale(1);
  top: 11.5cqh;
  left: calc(50% + 14.8cqh);
  height: 6.5cqh;
  width: 6.5cqh;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
  pointer-events: none;
  z-index: 10;
  transition: transform 0.05s ease; /* 50ms animation for scale */
}

#undo-button.loaded {
  opacity: 1;
  pointer-events: auto;
}

#undo-button:hover {
  transform: translateX(-100%) scale(1.3); /* Scale to 130% on hover */
	background-color: transparent
}

#undo-button.clicked {
  transform: translateX(-100%) scale(0.75); /* Scale to 75% on click */
}

#dig-button {
  position: absolute;
  top: 10.2cqh;
  left: calc(50% - 3cqh);
  height: 9cqh;
  width: 9cqh;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
  opacity: 0.5;
  pointer-events: none;
  z-index: 10;
  transform: scale(1);
  transition: transform 0.05s ease,
}

#dig-button.loaded {
  opacity: 1;
  pointer-events: auto;
}

#dig-button:hover {
  transform: scale(1.3); /* Scale to 130% on hover */
	background-color: transparent
}

#dig-button.clicked {
  transform: scale(0.75); /* Scale to 75% on click */
}

#home-button {
  position: absolute;
  transform: translateX(-100%) scale(1);
  top: 11.5cqh;
  left: calc(50% - 6.2cqh);
  height: 6.5cqh;
  width: 6.5cqh;
  cursor: pointer;
  display: flex;
  justify-content: center;
  align-items: center;
  pointer-events: none;
  z-index: 10;
  transition: transform 0.05s ease; /* 50ms animation for scale */
}

#home-button.loaded {
  opacity: 1;
  pointer-events: auto;
}

#home-button:hover {
  transform: translateX(-100%) scale(1.3); /* Scale to 130% on hover */
	background-color: transparent
}

#home-button.clicked {
  transform: translateX(-100%) scale(0.75); /* Scale to 75% on click */
}

#undo-button img, #dig-button img, #home-button img {
  width: 100%;
  height: 100%;
  object-fit: contain;
}

#roll-button {
	position: absolute;
	font-family: 'Bebas Neue', sans-serif;
	letter-spacing: .1dvh; /* Adjust the value as needed */
	bottom: 5dvh;
	left: 50%;
	transform: translateX(-50%);
	height: 6dvh;
	width: 15dvh;
	font-size: 3dvh;
	background-color: #333;
	color: white;
	border: none;
	border-radius: 0.5dvh;
	cursor: pointer;
	display: flex;
	justify-content: center;
	align-items: center;
	padding: 1dvh 2dvh;
	opacity: 0.5;
	pointer-events: none;
	z-index: 10;
	transition: background-color 0.3s ease, box-shadow 0.3s ease;
}
#roll-button:hover {
	background-color: #555;
	box-shadow: 0 0 0.5dvh rgba(255, 255, 255, 0.3);
}
#roll-button.loading,
#dig-button.loading, #undo-button.loading {
	opacity: 0.5;
	pointer-events: none;
}
#roll-button.loaded,
#dig-button.loaded, #undo-button.loaded {
	opacity: 1;
	pointer-events: auto;
}
#roll-sheet {
	background-color: #ffffff;
	position: relative;
}


#scoresheet {
	background-color: #purple;
	position: relative;
	container-type:size;
}
.nav-button {
  position: fixed;
  bottom: 2dvh;
  height: 5.6dvh;
  width: 5.6dvh;
  font-size: 3dvh; /* Reduced from 3.4dvh for better centering */
  line-height: 5.6dvh; /* Match button height */
  background-color: #333;
  color: white;
  border: none;
  border-radius: 1dvh;
  cursor: pointer;
  z-index: 10;
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 0; /* Remove padding to avoid offset */
  transition: background-color 0.3s ease, box-shadow 0.3s ease;
	transform: scale(1);
}
.nav-button:hover {
  background-color: #555;
  box-shadow: 0 0 0.5dvh rgba(255, 255, 255, 0.3);
	transform: scale(1.2);
}
#left-button {
  left: 2dvh;
}
#right-button {
  right: 2dvh;
}
.hidden {
	display: none;
}
.grid {
  position: relative;
  width: 100%;
  height: 100%;
  display: grid;
  grid-template: repeat(10, 1fr) / repeat(10, 1fr);
  overflow: visible; /* Prevent clipping of SVG stroke */
	container-type:size;
	-webkit-transform: translateZ(0);
}

.cell {
	width: 100%;
	height: 100%;
	background-color: transparent;
	border: none;
	cursor: pointer;
	box-sizing: border-box;
	position: relative;
}

.cell.no-pointer, .cell.disabled, .cell.committed {
	cursor: default; /* No pointer for non-clickable, disabled, or committed cells */}

.edge-outline {
  position: absolute;
  background-color: black; /* Solid black fill */
  pointer-events: none;
  box-sizing: border-box;
}
/* SVG container for polyomino outline */
.polyomino-svg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 10;
	-webkit-transform: translateZ(0); /* WebKit redraw fix */
	overflow:visible;
}
.polyomino-svg path {
  fill: none;
  stroke: black;
  stroke-width: 1.1cqh;
  vector-effect: non-scaling-stroke;
  stroke-linecap: round;
  stroke-linejoin: round;
	-webkit-transform: translateZ(0); /* WebKit redraw fix */
}
.polyomino-svg.locked-svg path {
  stroke: rgba(90, 90, 90, 1); !important;
}
.committed {
  background-color: rgba(0, 0, 0, 0.25);
  z-index: 5;
}

.disabled {
	pointer-events: none;
}
@media (min-aspect-ratio: 4/3) {
	#game-container {
		width: 200%;
		transform: translateX(-50vw);
	}
	#dig-roll {
		width: 50vw;
		height: 100dvh;
	}
	#scoresheet {
		width: 50vw;
		height: 100dvh;
	}
	#roll-sheet {
		width: 50vw;
		height: 100dvh;
		}
	#right-button,
	#return-home-score {
		display: none;
	}
}
@media (min-aspect-ratio: 16/9) {
	#game-container {
		width: 100%;
		transform: translateX(0);
	}
	#dig-roll {
		width: 33.33vw;
		height: 100dvh;
	}
	#roll-sheet {
		width: 33.33vw;
		height: 100dvh;
	}
	#scoresheet {
		width: 33.33vw;
		height: 100dvh;
	}
	#left-button,
	#right-button,
	#return-dig-roll-roll,
	#return-home-score {
		display: none;
	}
}



.circle-clicker {
	width: 3.4cqh;
	height: 3.4cqh;
	position: absolute;
	z-index: 20;
	pointer-events: none;
	display: flex;
	justify-content: center;
	align-items: center;
	overflow: visible;
}
.circle-clicker svg {
	width: 100%;
	height: 100%;
	overflow: visible;
}
.circle-clicker circle {
	fill: none;
  stroke: black;
  stroke-width: 6.8;
  stroke-dasharray: 110;
  stroke-dashoffset: 110;
  stroke-linecap: round;
  transition: stroke-dashoffset 0.3s ease-out;
}
.circle-clicker.circled circle {
	stroke-dashoffset: 0;
}
.circle-cross-off-clicker {
	width: 2.6dvh;
	height: 2.6dvh;
	position: absolute;
	z-index: 20;
	pointer-events: none;
	cursor: none;
	background-color: transparent;
	display: flex;
	justify-content: center;
	align-items: center;
}
.circle-cross-off-clicker svg {
	width: 100%;
	height: 100%;
}
.circle-cross-off-clicker circle {
	fill: none;
	stroke: black;
	stroke-width: 6.8;
	stroke-dasharray: 110;
	stroke-dashoffset: 110;
	stroke-linecap: round;
	transition: stroke-dashoffset 0.3s ease-out;
}
.circle-cross-off-clicker.circled circle {
	stroke-dashoffset: 0;
}
.circle-cross-off-clicker line {
	stroke: black;
	stroke-width: 1.5dvh;
	stroke-linecap: round;
	stroke-dasharray: 100;
	stroke-dashoffset: 100;
	transition: stroke-dashoffset 100ms ease-out;
}
.circle-cross-off-clicker.crossed-off line {
	stroke-dashoffset: 0;
}
.diamond-circle-clicker {
	width: 2.6cqh;
	height: 2.6cqh;
	position: absolute;
	z-index: 20;
	pointer-events: none;
	background-color: transparent;
	display: flex;
	justify-content: center;
	align-items: center;
}
.diamond-circle-clicker svg {
	width: 100%;
	height: 100%;
	overflow:visible;
}
.diamond-circle-clicker circle {
	fill: none;
	stroke: black;
	stroke-width: 6.8;
	stroke-dasharray: 110;
	stroke-dashoffset: 110;
	stroke-linecap: round;
	transition: stroke-dashoffset 0.3s ease-out;
}
.diamond-circle-clicker.circled circle {
	stroke-dashoffset: 0;
	stroke: black;
}
.diamond-score-readout {
	width: 6.5cqh;
	height: 6.5cqh;
	position: absolute;
	z-index: 20;
	background-color: transparent;
	display: flex;
	justify-content: center;
	align-items: center;
	font-family: "Covered By Your Grace", cursive;
	font-size: 4cqh;
	color: black;
	top: 26.5cqh;
	left: calc(50% + 18.4cqh);
}

.q-s-c-score-readout {
	width: 6.5cqh;
	height: 6.5cqh;
	position: absolute;
	z-index: 20;
	background-color: transparent;
	display: flex;
	justify-content: center;
	align-items: center;
	font-family: "Covered By Your Grace", cursive;
	font-size: 4cqh;
	color: black;
	top: 2.3cqh;
	left: calc(50% + 18.4cqh);
}

.quartz-circle-clicker {
	width: 2.6cqh;
	height: 2.6cqh;
	position: absolute;
	z-index: 20;
	pointer-events: default;
	display: flex;
	justify-content: center;
	align-items: center;
}
.quartz-circle-clicker svg {
	width: 100%;
	height: 100%;
	overflow:visible;
}
.quartz-circle-clicker circle {
	fill: none;
	stroke: black;
	stroke-width: 6.8;
	stroke-dasharray: 110;
	stroke-dashoffset: 110;
	stroke-linecap: round;
	transition: stroke-dashoffset 0.3s ease-out;
}
.quartz-circle-clicker.circled circle {
	stroke-dashoffset: 0;
	stroke: black;
}
.sandstone-circle-clicker {
	width: 2.6cqh;
	height: 2.6cqh;
	position: absolute;
	z-index: 20;
	pointer-events: default;
	display: flex;
	justify-content: center;
	align-items: center;
}
.sandstone-circle-clicker svg {
	width: 100%;
	height: 100%;
	overflow:visible;
}
.sandstone-circle-clicker circle {
	fill: none;
	stroke: black;
	stroke-width: 6.8;
	stroke-dasharray: 110;
	stroke-dashoffset: 110;
	stroke-linecap: round;
	transition: stroke-dashoffset 0.3s ease-out;
}
.sandstone-circle-clicker.circled circle {
	stroke-dashoffset: 0;
	stroke: black;
}
.coal-circle-clicker {
	width: 2.6cqh;
	height: 2.6cqh;
	position: absolute;
	z-index: 20;
	display: flex;
	justify-content: center;
	align-items: center;
}
.coal-circle-clicker svg {
	width: 100%;
	height: 100%;
	overflow:visible;
}
.coal-circle-clicker circle {
	fill: none;
	stroke: black;
	stroke-width: 6.8;
	stroke-dasharray: 110;
	stroke-dashoffset: 110;
	stroke-linecap: round;
	transition: stroke-dashoffset 0.3s ease-out;
}
.coal-circle-clicker.circled circle {
	stroke-dashoffset: 0;
	stroke: black;
}

.quartz-bonus-circle {
	width: 4cqh;
	height: 4cqh;
	position: absolute;
	z-index: 20;
	display: flex;
	justify-content: center;
	align-items: center;
}
.sandstone-bonus-circle {
	width: 4cqh;
	height: 4cqh;
	position: absolute;
	z-index: 20;
	display: flex;
	justify-content: center;
	align-items: center;
}
.coal-bonus-circle {
	width: 4cqh;
	height: 4cqh;
	position: absolute;
	z-index: 20;
	display: flex;
	justify-content: center;
	align-items: center;
}
.quartz-bonus-circle svg,
.sandstone-bonus-circle svg,
.coal-bonus-circle svg {
	width: 100%;
	height: 100%;
}
.quartz-bonus-circle circle,
.sandstone-bonus-circle circle,
.coal-bonus-circle circle {
	fill: none;
	stroke: black;
	stroke-width: 4.5; /* Adjusted to match visual thickness of regular clickers */
	stroke-dasharray: 110;
	stroke-dashoffset: 110;
	stroke-linecap: round;
	transition: stroke-dashoffset 0.3s ease-out;
}
.quartz-bonus-circle.circled circle,
.sandstone-bonus-circle.circled circle,
.coal-bonus-circle.circled circle {
	stroke-dashoffset: 0;
	stroke: black;
}

.silver-circle-clicker {
	width: 2.6cqh;
	height: 2.6cqh;
	position: absolute;
	z-index: 20;
	background-color: transparent;
	display: flex;
	justify-content: center;
	align-items: center;
}
.silver-circle-clicker svg {
	width: 100%;
	height: 100%;
	overflow:visible;
}
.silver-circle-clicker circle {
	fill: none;
	stroke: black;
	stroke-width: 6.8;
	stroke-dasharray: 110;
	stroke-dashoffset: 110;
	stroke-linecap: round;
	transition: stroke-dashoffset 0.3s ease-out;
}
.silver-circle-clicker.circled circle {
	stroke-dashoffset: 0;
	stroke: black;
}
.silver-score-readout {
	width: 6.5cqh;
	height: 6.5cqh;
	position: absolute;
	z-index: 20;
	background-color: transparent;
	display: flex;
	justify-content: center;
	align-items: center;
	font-family: "Covered By Your Grace", cursive;
	font-size: 4cqh;
	color: black;
	top: 18.6cqh;
	left: calc(50% + 18.4cqh);
}

.lapis-circle-clicker {
	width: 2.6cqh;
	height: 2.6cqh;
	position: absolute;
	z-index: 20;
	background-color: transparent;
	display: flex;
	justify-content: center;
	align-items: center;
}
.lapis-circle-clicker svg {
	width: 100%;
	height: 100%;
	overflow:visible;
}
.lapis-circle-clicker circle {
	fill: none;
	stroke: black;
	stroke-width: 6.8;
	stroke-dasharray: 110;
	stroke-dashoffset: 110;
	stroke-linecap: round;
	transition: stroke-dashoffset 0.3s ease-out;
}
.lapis-circle-clicker.circled circle {
	stroke-dashoffset: 0;
	stroke: black;
}
.lapis-score-readout {
  width: 6.5cqh;
	height: 6.5cqh;
	position: absolute;
	z-index: 20;
	background-color: transparent;
	display: flex;
	justify-content: center;
	align-items: center;
	font-family: "Covered By Your Grace", cursive;
	font-size: 4cqh;
	color: black;
	top: 34.4cqh;
	left: calc(50% + 18.4cqh);
}

.peridot-circle-clicker {
  width: 2.6cqh;
	height: 2.6cqh;
  position: absolute;
  z-index: 20;
  display: flex;
  justify-content: center;
  align-items: center;
}
.peridot-circle-clicker svg {
  width: 100%;
  height: 100%;
	overflow:visible;
}
.peridot-circle-clicker circle {
  fill: none;
  stroke: black;
  stroke-width: 6.8;
  stroke-dasharray: 110;
  stroke-dashoffset: 110;
  stroke-linecap: round;
  transition: stroke-dashoffset 0.3s ease-out;
}
.peridot-circle-clicker.circled circle {
  stroke-dashoffset: 0;
  stroke: black;
}
.peridot-score {
  position: absolute;
  width: 2.6dvh;
  height: 2.6dvh;
  font-size: 2dvh;
  color: black;
  text-align: center;
  display: flex;
  justify-content: center;
  align-items: center;
}

.peridot-score-1, .peridot-score-2, .peridot-score-3, .peridot-score-4, .peridot-score-5 {
  position: absolute;
  width: 4.6cqh;
  height: 4.6cqh;
  font-family: "Covered By Your Grace", cursive;
	font-size: 4cqh;
  color: black;
  text-align: center;
  display: flex;
  justify-content: center;
  align-items: center;
}
.peridot-score-readout {
  width: 6.5cqh;
	height: 6.5cqh;
	position: absolute;
	z-index: 20;
	background-color: transparent;
	display: flex;
	justify-content: center;
	align-items: center;
	font-family: "Covered By Your Grace", cursive;
	font-size: 4cqh;
	color: black;
	top: 42.3cqh;
	left: calc(50% + 18.4cqh);
}

.topaz-circle-clicker {
	width: 2.6cqh;
	height: 2.6cqh;
	position: absolute;
	z-index: 20;
	background-color: transparent;
	display: flex;
	justify-content: center;
	align-items: center;
}
.topaz-circle-clicker svg {
	width: 100%;
	height: 100%;
	overflow:visible;
}
.topaz-circle-clicker circle {
	fill: none;
	stroke: black;
	stroke-width: 6.8;
	stroke-dasharray: 110;
	stroke-dashoffset: 110;
	stroke-linecap: round;
	transition: stroke-dashoffset 0.3s ease-out;
}
.topaz-circle-clicker.circled circle {
	stroke-dashoffset: 0;
	stroke: black;
}

.topaz-score-readout {
  width: 6.5cqh;
	height: 6.5cqh;
	position: absolute;
	z-index: 20;
	background-color: transparent;
	display: flex;
	justify-content: center;
	align-items: center;
	font-family: "Covered By Your Grace", cursive;
	font-size: 4cqh;
	color: black;
	top: 49.95cqh;
	left: calc(50% + 18.4cqh);
}

.opal-circle-clicker {
  width: 2.6cqh;
	height: 2.6cqh;
  position: absolute;
  z-index: 20;
  background-color: transparent;
  display: flex;
  justify-content: center;
  align-items: center;
}
.opal-circle-clicker svg {
  width: 100%;
  height: 100%;
	overflow:visible;
}
.opal-circle-clicker circle {
  fill: none;
  stroke: black;
  stroke-width: 6.8;
  stroke-dasharray: 110;
  stroke-dashoffset: 110;
  stroke-linecap: round;
  transition: stroke-dashoffset 0.3s ease-out;
}
.opal-circle-clicker.circled circle {
  stroke-dashoffset: 0;
  stroke: black;
}
.opal-score-readout {
  width: 6.5cqh;
	height: 6.5cqh;
	position: absolute;
	z-index: 20;
	background-color: transparent;
	display: flex;
	justify-content: center;
	align-items: center;
	font-family: "Covered By Your Grace", cursive;
	font-size: 4cqh;
	color: black;
	top: 57.65cqh;
	left: calc(50% + 18.4cqh);
}
.amber-circle-clicker {
  width: 2.6cqh;
	height: 2.6cqh;
  position: absolute;
  z-index: 20;
  background-color: transparent;
  display: flex;
  justify-content: center;
  align-items: center;
}
.amber-circle-clicker svg {
  width: 100%;
  height: 100%;
	overflow:visible;
}
.amber-circle-clicker circle {
  fill: none;
  stroke: black;
  stroke-width: 6.8;
  stroke-dasharray: 110;
  stroke-dashoffset: 110;
  stroke-linecap: round;
  transition: stroke-dashoffset 0.3s ease-out;
}
.amber-circle-clicker.circled circle {
  stroke-dashoffset: 0;
  stroke: black;
}
.amber-score-readout {
  width: 6.5cqh;
	height: 6.5cqh;
	position: absolute;
	z-index: 20;
	background-color: transparent;
	display: flex;
	justify-content: center;
	align-items: center;
	font-family: "Covered By Your Grace", cursive;
	font-size: 4cqh;
	color: black;
	top: 65.8cqh;
	left: calc(50% + 18.4cqh);
}

.final-score {
  width: 8dvh;
  height: 8dvh;
  position: absolute;
  z-index: 20;
  display: flex;
  justify-content: center;
  align-items: center;
  font-family: "Covered By Your Grace", cursive;
  font-size: 7dvh;
  color: black;
  opacity: 1;
	background-color:red;
}
.final-score.hidden-score {
  opacity: 0;
}

@keyframes polyomino-flash {
  0% { stroke: white; stroke-width: 0.25dvh; }
  2% { stroke: white; stroke-width: 1.8dvh; }
  100% { stroke: white; stroke-width: 0.25dvh; }
}
.polyomino-svg.flash path {
  animation: polyomino-flash 200ms ease-in forwards;
}

.cell-flash {
  animation: cell-flash 500ms ease;
}
@keyframes cell-flash {
  0% { background-color: transparent;}
  10% { background-color: #ffffff;}
	90% { background-color: transparent;}
  100% { background-color: transparent;}
}

@keyframes pulse-roll {
  0% { transform: translateX(-50%) scale(1); }
  50% { transform: translateX(-50%) scale(1.1); }
  100% { transform: translateX(-50%) scale(1); }
}

@keyframes pulse-dig {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}

.pulsing-roll {
  animation: pulse-roll 1000ms ease-in-out infinite;
}

.pulsing-dig {
  animation: pulse-dig 1000ms ease-in-out infinite;
}

@keyframes spin {
  0% { transform: scale(1) rotate(0deg); }
  100% { transform: scale(1) rotate(720deg); }
}

#dig-button.bonus-mode {
  background-image: url('https://i.imgur.com/ZI42Lkq.png');
  animation: spin 0.5s ease-in-out;
}

.oil-square {
  width: 4.3cqh;
  height: 4.3cqh;
  position: absolute;
  z-index: 200;
	pointer-events:none;
	background-image: url('https://i.imgur.com/ioTAHqi.png');
	background-size: contain;
	background-repeat: no-repeat;
	background-position: center;
  display: none;
  justify-content: center;
  align-items: center;
}

.oil-square-final {
	width: 4.3cqh;
  height: 4.3cqh;
  position: absolute;
  z-index: 200;
	pointer-events:none;
	background-image: url('https://i.imgur.com/GyOYDfA.png');
	background-size: contain;
	background-repeat: no-repeat;
	background-position: center;
  display: none;
  justify-content: center;
  align-items: center;
}

@keyframes pulse-oil-squares {
  0% { transform: scale(1); }
  50% { transform: scale(1.3); }
  100% { transform: scale(1); }
}

.pulsing-oil-square {
  animation: pulse-oil-squares 1000ms ease-in-out infinite;
}

.ng-cross-off {
  width: 4.7cqh;
  height: 4.7cqh;
  position: absolute;
  transform: rotate(-45deg);
  z-index: 20;
  border-radius: 4cqh;
  display: flex;
	background-color: transparent;
  justify-content: center;
  align-items: center;
  pointer-events: none; /* Not clickable by default */
  opacity: 0.5;
}

.ng-cross-off.clickable {
  pointer-events: auto;
  opacity: 1;
  cursor: pointer;
}

.ng-cross-off.crossed-off {
  pointer-events: auto;
  opacity: 1;
  cursor: pointer;
}

.ng-cross-off .line-draw {
  width: 0;
  height: 0.7cqh;
  background-color: black;
  border-radius: 1cqh;
  transition: width 100ms ease-out;
  transform-origin: left;
}

.ng-cross-off.crossed-off .line-draw {
  width: 100%;
}

.ng-cross-off.used {
  pointer-events: none !important;
  opacity: 1;
}

.ng-bonus {
  width: 4.7cqh;
  height: 4.7cqh;
  position: absolute;
  background-image: url('https://i.imgur.com/C6SGy1S.png');
  background-size: contain;
  background-repeat: no-repeat;
  background-position: center;
  display: none;
  pointer-events: none; /* Don't interfere with clicks */
  z-index: 21; /* Higher than NG-Crossoff (z-index 20) */
}

@keyframes pulse-ng-bonus {
  0% { transform: scale(1); }
  50% { transform: scale(1.3); }
  100% { transform: scale(1); }
}

.pulsing-ng-bonus {
  animation: pulse-ng-bonus 1000ms ease-in-out infinite;
}

.finish-button {
  position: absolute;
  bottom: 10cqh; /* Bottom-aligned in scoresheet, above any nav */
  left: 50%;
  transform: translateX(-50%);
  width: 20cqh;
  height: 6cqh;
  font-family: 'Bebas Neue', sans-serif;
  font-size: 2.5cqh;
  background-color: #333;
  color: white;
  border: none;
  border-radius: 0.5cqh;
  cursor: pointer;
  z-index: 30; /* Above circles/readouts */
  transition: background-color 0.3s ease, box-shadow 0.3s ease;
  opacity: 1; /* Always visible/clickable */
  pointer-events: auto;
}

.finish-button:hover {
  background-color: #555;
  box-shadow: 0 0 0.5dvh rgba(255, 255, 255, 0.3);
}

.end-game-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100vw;
  height: 100dvh;
  background-color: white;
  z-index: 1000; /* Above everything */
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.3s ease, visibility 0.3s ease;
	container-type:size;
}

.end-game-overlay:not(.hidden) {
  opacity: 1;
  visibility: visible;
}

.screenshot-container {
  position: relative;
  width: 56.35dvh; /* Proportionate to 75dvh dig sheet height (2160w / 2878h * 75dvh) */
  height: 100dvh;
  margin-top: 7.5dvh; /* Center vertically to top edge: (100dvh - 85dvh)/2 = 7.5dvh top margin */
  background-color: transparent; /* White inherited, but transparent for cloning */
  overflow: visible; /* Crop any overflow from clones */
	margin-top: 3.5dvh; /* Flush to top edge instead of 7.5dvh centering */
}


/* Styles for cloned elements inside screenshot (match original but relative to container) */
.screenshot-container #dig-sheet-clone,
.screenshot-container #dig-sheet-overlay-clone {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100dvh; /* Dig sheet takes top 75dvh of 85dvh container */
}

/* Hide polyomino SVGs in share mode */
.screenshot-container .polyomino-svg {
  display: none !important;
}

/* Ensure committed tints show (no outlines, but gray fill) */
.screenshot-container .committed {
  background-color: rgba(0, 0, 0, 0.4); /* Keep original tint or adjust */
  transform: scale(0.85) translateY(-.1dvh); /* Shrink 10% for space between cells (adjust to 0.85 for more space) */
  border-radius: 0.5dvh; /* Rounded corners (adjust for more/less curve) */
  transform-origin: center; /* Scale from center to keep even spacing */
}

/* Reposition final-score to bottom of screenshot */
.screenshot-container #final-score-clone {
  top: 90dvh !important; /* Relative to screenshot top (75dvh dig + 11dvh offset) */
  left: calc(50% - 0.3dvh) !important;
  transform: translate(-50%, -50%) !important;
  opacity: 1 !important; /* Force visible */
}



.scoresheet-button {
  position: absolute;
  bottom: 10cqh; /* Bottom-center on scoresheet */
  left: 50%;
  transform: translateX(-50%);
  width: 20cqh;
  height: 6cqh;
  font-family: 'Bebas Neue', sans-serif;
  font-size: 2.5cqh;
  background-color: #333;
  color: white;
  border: none;
  border-radius: 0.5cqh;
  cursor: pointer;
  z-index: 30;
  transition: background-color 0.3s ease, box-shadow 0.3s ease, bottom 0.5s ease, left 0.5s ease;
  opacity: 1;
  pointer-events: auto;
}

.scoresheet-button:hover {
  background-color: #555;
  box-shadow: 0 0 0.5dvh rgba(255, 255, 255, 0.3);
	transform: translateX(-50%) scale(1.1);
}

.off-screen {
  bottom: -10cqh; /* Hidden off-bottom */
  opacity: 0;
  pointer-events: none;
}

.final-score-bubble {
  position: absolute;
  bottom: 8.3cqh; /* Your tweak for centering */
  left: 50%;
  transform: translateX(-50%) scale(1.0);
  width: 10cqh;
  height: 10cqh;
  background-image: url('https://i.imgur.com/FIWlNcD.png');
  background-size: contain;
  background-position: center;
  background-repeat: no-repeat;
  display: flex;
  justify-content: center;
  align-items: center;
  font-family: "Covered By Your Grace", cursive;
  font-size: 5cqh;
  color: black;
  z-index: 30;
  opacity: 0;
  pointer-events: none;
  transition: bottom 0.5s ease, left 0.5s ease, opacity 0.5s ease;
}



.hidden-state {
  opacity: 0;
  pointer-events: none;
}

/* Animation keyframes */
@keyframes slide-down {
  0% { bottom: 10cqh; opacity: 1; }
  100% { bottom: -10cqh; opacity: 0; }
}

@keyframes slide-up {
  0% { bottom: -10cqh; opacity: 0; }
  100% { bottom: 8.3cqh; opacity: 1; } /* Bubble's centering bottom */
}

@keyframes spin-scale {
  0% { transform: translateX(-50%) rotate(0deg) scale(1.0); bottom: 0cqh; }
  50% { transform: translateX(-50%) rotate(360deg) scale(1.0); bottom: 20.3cqh;}
  100% { transform: translateX(-50%) rotate(720deg) scale(1.0); bottom: 8.3cqh;}
}

@keyframes slide-right {
  0% { bottom: 8.3cqh; left: 50%; transform: translateX(-50%); opacity: 1; }
  100% { bottom: 8.3cqh; left: calc(50% + 21.3cqh); transform: translateX(-50%); opacity: 1; } /* Shift center 18dvh right, force visible */
}

@keyframes slide-up-button {
  0% { bottom: -10cqh; opacity: 0; }
  100% { bottom: 10cqh; opacity: 1; } /* Button's original bottom */
}

.screenshot-explainer {
  position: absolute;
  bottom: 8.3cqh; /* Match bubble's centering */
  left: calc(50% - 20.5cqh); /* Mirror bubble's right shift to left */
  transform: translateX(-50%);
  width: 13cqh;
  height: 10cqh;
  display: flex;
  justify-content: flex-end; /* Right-align text */
  align-items: center;
  font-family: "Covered By Your Grace", cursive;
  font-size: 2.5cqh; /* Adjust for readability */
  color: black;
  z-index: 30;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.5s ease;
}

/* Fade-in animation */
@keyframes fade-in {
  0% { opacity: 0; }
  100% { opacity: 1; }
}

@media (max-aspect-ratio: 9/16) {
	.grid-placeholder {
		left:calc(50% + 5.8vw);
		top:calc(50% - 36.5vw);
		width:74.5vw;
		height:74.5vw;
	}
	#cross-off-container {
		width: 100cqw;
		height: calc(133.24cqw);
	}
	#roll-sheet-switcher {
		left:calc(50% +.8vw);
		top:calc(50% - 80.5vw);
		width:7vw;
		height:7vw;
	}
	#dig-sheet-switcher {
		left:calc(50% - 39.5cqw);
		top:calc(50% - 51.8cqw);
		width:7cqw;
		height:7cqw;
	}
	.section-image-wrapper {
		width: 100cqw;
		height: 177.639cqw;
	}
	.screenshot-container {
		width: 100cqw;
	}
}

/* Tutorial Overlay (full-panel blocker inside #dig-roll) */
.tutorial-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 4000; /* Below card but above game elements */
    visibility: hidden; /* Hidden initial */
    pointer-events: none; /* Initial no block */
}

.tutorial-overlay.visible {
    visibility: visible; /* Show when message up */
    pointer-events: auto; /* Block clicks on underlying elements */
}

/* Tutorial Card (child of overlay) */
.tutorial-card {
    position: absolute; /* Position within overlay */
    bottom: -100vh; /* Start off-screen bottom */
    left: 50%;
    transform: translate(-50%, 50%);
    width: 80vw;
    max-width: 400px;
    height: auto; /* Adapt to content */
    min-height: 20dvh; /* Ensure minimum size */
    padding: 2dvh;
    background-color: rgba(255, 255, 255, 0.95); /* Semi-transparent white */
    border-radius: 1dvh;
    box-shadow: 0 0.5dvh 1dvh rgba(0, 0, 0, 0.3);
    text-align: center;
    z-index: 5000; /* Higher than overlay to be clickable */
    opacity: 0; /* Start invisible */
    visibility: hidden; /* Hidden initial */
    transition: bottom 0.5s ease-in-out, opacity 0.5s ease-in-out; /* Animate slide and fade */
}

.tutorial-card.visible {
    bottom: 50%; /* Center vertically */
    opacity: 1; /* Fully visible */
    visibility: visible; /* Show with animation */
}

#tutorial-text {
    font-family: 'Montserrat', sans-serif;
    font-size: 2.5dvh;
    color: black;
    margin-bottom: 2dvh;
}

#tutorial-ok {
    width: 20dvh;
    height: 6dvh;
    font-size: 3dvh;
    margin: 0 auto; /* Center horizontally */
}

/* Highlight for guided cells */
.tutorial-highlight {
    background-color: rgba(255, 255, 0, 0.3); /* Initial yellow tint fill */
    animation: pulse-highlight 1s infinite;
    filter: blur(0.5vh); /* Your added blur */
}

@keyframes pulse-highlight {
    0% { background-color: rgba(255, 255, 0, 0.3); }
    50% { background-color: rgba(255, 255, 0, 0.7); }
    100% { background-color: rgba(255, 255, 0, 0.3); }
}

    </style>
</head>
<body>

    <link href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;700&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Covered+By+Your+Grace&family=Gamja+Flower&family=Patrick+Hand&family=Single+Day&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">

<div id="end-game-overlay" class="end-game-overlay hidden">
	<div id="screenshot-container" class="screenshot-container">
		<!-- Cloned dig sheet content will be injected here via JS -->
	</div>
	<div id="share-score" class="share-score">
	</div>
</div>

<!-- opening menu hidden-->
<div id="opening-menu">
	<button id="resume-button" class="menu-button" style="display: none;">Resume</button>
	<button id="free-play-button" class="menu-button">Free Play</button>
	<button id="daily-challenge-button" class="menu-button">The Daily Gem</button>
	<div id="daily-challenge-timer"></div>
	<button id="how-to-play-button" class="menu-button-white">How to Play</button>
	<button id="clearly-sharp-button" class="menu-button-white">Clearly Sharp</button>
	<div id="free-play-submenu" style="display: none;">
		<button id="back-button" class="back-button"><svg xmlns="http://www.w3.org/2000/svg" height="24dvh" viewBox="0 -960 960 960" width="24dvh" fill="#FFFFFF">
				<path d="m313-440 224 224-57 56-320-320 320-320 57 56-224 224h487v80H313Z" />
			</svg></button>
		<div class="submenu-content">
			<h2>Dig Sheet</h2>
			<div class="dig-sheet-buttons">
				<div class="dig-sheet-row">
					<button class="sheet-button" data-dig-sheet="dig-sheet-a"><img src="https://i.imgur.com/HDpEsz9.png" alt="Dig Sheet A"></button>
					<button class="sheet-button" data-dig-sheet="dig-sheet-b"><img src="https://i.imgur.com/BQwShon.png" alt="Dig Sheet B"></button>
					<button class="sheet-button" data-dig-sheet="dig-sheet-c"><img src="https://i.imgur.com/SRPkaWH.png" alt="Dig Sheet C"></button>
					<button class="sheet-button" data-dig-sheet="dig-sheet-d"><img src="https://i.imgur.com/vZFkrYT.png" alt="Dig Sheet D"></button>
				</div>
				<div class="dig-sheet-row">
					<button class="sheet-button" data-dig-sheet="dig-sheet-e"><img src="https://i.imgur.com/61AGFQU.png" alt="Dig Sheet E"></button>
					<button class="sheet-button" data-dig-sheet="dig-sheet-f"><img src="https://i.imgur.com/W6ihlfP.png" alt="Dig Sheet F"></button>
					<button class="sheet-button" data-dig-sheet="dig-sheet-g"><img src="https://i.imgur.com/VoYIEQ7.png" alt="Dig Sheet G"></button>
					<button class="sheet-button" data-dig-sheet="dig-sheet-h"><img src="https://i.imgur.com/uQsBTwt.png" alt="Dig Sheet H"></button>
				</div>
			</div>
			<h2>Roll Sheet</h2>
			<div class="roll-sheet-buttons">
				<button class="sheet-button" data-roll-sheet="roll-sheet-a"><img src="https://i.imgur.com/8PIVNrn.png" alt="Roll Sheet A"></button>
				<button class="sheet-button" data-roll-sheet="roll-sheet-b"><img src="https://i.imgur.com/jduT1AK.png" alt="Roll Sheet B"></button>
			</div>
			<div class="submenu-actions">
				<button id="play-button" class="menu-button" disabled>Play</button>
				<button id="random-button" class="menu-button">Random</button>
			</div>
		</div>
	</div>
	<!-- Clearly Sharp sub-menu remains unchanged -->
	<div id="clearly-sharp-submenu" style="display: none;">
		<button id="back-clearly-sharp" class="back-button"><svg xmlns="http://www.w3.org/2000/svg" height="24dvh" viewBox="0 -960 960 960" width="24dvh" fill="#FFFFFF">
				<path d="m313-440 224 224-57 56-320-320 320-320 57 56-224 224h487v80H313Z" />
			</svg></button>
		<div class="submenu-content">
			<img src="https://i.imgur.com/OLU7c2s.png" alt="Clearly Sharp Logo" class="clearly-sharp-logo">
			<p class="clearly-sharp-text">Clearly Sharp is the graphic design work of Daniel Young. Click to learn more and get help with your next logo, print, or digital design:</p>
			<a href="https://clearlysharp.com" target="_blank" class="menu-button">Check it Out</a>
		</div>
	</div>
	<img id="game-logo" src="https://i.imgur.com/5opdz7e.png" alt="Game Logo">
</div>

<div id="game-container">
	<div id="roll-sheet" class="section">
		<div class="section-image-wrapper">
			<img src="https://i.imgur.com/U3dEe1S.png" alt="Roll Sheet" class="section-image">
			<div id="roll-sheet-switcher"></div>
		</div>
	</div>
	<div id="dig-roll" class="section">

		<div id="dig-sheet">

			<div class="grid-placeholder">
				<div class="grid" id="grid"></div>
			</div>
			<div id="dig-sheet-overlay">

				<div id="dig-sheet-switcher"></div>
				<img src="https://i.imgur.com/i8KpuK2.png" alt="Dig Sheet Overlay">
				<div id="cross-off-container">
					<div id="dig-button" class="loaded"><img src="https://i.imgur.com/7tDYHqX.png" alt="Dig"></div>
					<div id="undo-button" class="loaded"><img src="https://i.imgur.com/mtBWnJM.png" alt="Undo"></div>
					<div id="home-button" class="loaded"><img src="https://i.imgur.com/YxlqWad.png" alt="Home"></div>
					<!-- Boulder Bonuses -->
					<div class="cross-off-clicker boulder-cross-off" style="top: 30.9cqh; left: 44.4cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker boulder-cross-off" style="top: 36.5cqh; left: 28cqh">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker boulder-cross-off" style="top: 42.1cqh; left: 49.8cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker boulder-cross-off" style="top: 64.5cqh; left: 49.8cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker boulder-cross-off" style="top: 70.1cqh; left: 39cqh;">
						<div class="line-draw"></div>
					</div>
					<!-- Row Bonuses -->
					<div class="cross-off-clicker row-cross-off" style="top: 25.5cqh; left: 5.8cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker row-cross-off" style="top: 31.1cqh; left: 5.8cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker row-cross-off" style="top: 36.7cqh; left: 5.8cqh">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker row-cross-off" style="top: 42.3cqh; left: 5.8cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker row-cross-off" style="top: 47.9cqh; left: 5.8cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker row-cross-off" style="top: 53.4cqh; left: 5.8cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker row-cross-off" style="top: 59.0cqh; left: 5.8cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker row-cross-off" style="top: 64.6cqh; left: 5.8cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker row-cross-off" style="top: 70.2cqh; left: 5.8cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker row-cross-off" style="top: 75.8cqh; left: 5.8cqh;">
						<div class="line-draw"></div>
					</div>
					<!-- Column Bonuses -->
					<div class="cross-off-clicker column-cross-off" style="top: 84.3cqh; left: 16.9cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker column-cross-off" style="top: 84.3cqh; left: 22.5cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker column-cross-off" style="top: 84.3cqh; left: 28cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker column-cross-off" style="top: 84.3cqh; left: 33.6cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker column-cross-off" style="top: 84.3cqh; left: 39.1cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker column-cross-off" style="top: 84.3cqh; left: 44.7cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker column-cross-off" style="top: 84.3cqh; left: 50.2cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker column-cross-off" style="top: 84.3cqh; left: 55.8cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker column-cross-off" style="top: 84cqh; left: 61.3cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-clicker column-cross-off" style="top: 84.3cqh; left: 66.9cqh;">
						<div class="line-draw"></div>
					</div>

					<!-- Oil and NG Circle Clickers -->
					<div class="circle-clicker oil-circle-clicker" style="top: 96.5cqh; left: 11.6cqh; transform: translate(-50%, -50%);">
						<svg viewBox="0 0 40 40">
							<circle cx="20" cy="20" r="17.5" />
						</svg>
					</div>
					<div class="circle-clicker oil-circle-clicker" style="top: 96.5cqh; left: 17.2cqh; transform: translate(-50%, -50%);">
						<svg viewBox="0 0 40 40">
							<circle cx="20" cy="20" r="17.5" />
						</svg>
					</div>
					<div class="circle-clicker oil-circle-clicker" style="top: 96.5cqh; left: 22.6cqh; transform: translate(-50%, -50%);">
						<svg viewBox="0 0 40 40">
							<circle cx="20" cy="20" r="17.5" />
						</svg>
					</div>
					<div class="circle-clicker oil-circle-clicker" style="top: 96.5cqh; left: 28.2cqh; transform: translate(-50%, -50%);">
						<svg viewBox="0 0 40 40">
							<circle cx="20" cy="20" r="17.5" />
						</svg>
					</div>
					<div class="circle-clicker oil-circle-clicker" style="top: 96.5cqh; left: 33.7cqh; transform: translate(-50%, -50%);">
						<svg viewBox="0 0 40 40">
							<circle cx="20" cy="20" r="17.5" />
						</svg>
					</div>
					<div class="circle-clicker oil-circle-clicker" style="top: 96.4cqh; left: 39.1cqh; transform: translate(-50%, -50%);">
						<svg viewBox="0 0 40 40">
							<circle cx="20" cy="20" r="17.5" />
						</svg>
					</div>
					<div class="circle-clicker oil-circle-clicker" style="top: 96.4cqh; left: 44.6cqh; transform: translate(-50%, -50%);">
						<svg viewBox="0 0 40 40">
							<circle cx="20" cy="20" r="17.5" />
						</svg>
					</div>

					<div class="circle-clicker ng-circle-clicker" style="top: 96.4cqh; left: 62.8cqh; transform: translate(-50%, -50%);">
						<svg viewBox="0 0 40 40">
							<circle cx="20" cy="20" r="17.5" />
						</svg>
					</div>

					<div class="circle-clicker ng-circle-clicker" style="top: 96.4cqh; left: 68.2cqh; transform: translate(-50%, -50%);">
						<svg viewBox="0 0 40 40">
							<circle cx="20" cy="20" r="17.5" />
						</svg>
					</div>

					<!-- Oil and NG Cross-Off Clickers -->
					<div class="oil-ng-cross-off-clicker" style="top: 90.9cqh; left: 14.8cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="oil-ng-cross-off-clicker" style="top: 90.9cqh; left: 25.8cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="oil-ng-cross-off-clicker" style="top: 90.9cqh; left: 31.3cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="oil-ng-cross-off-clicker" style="top: 90.9cqh; left: 36.7cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="oil-ng-cross-off-clicker" style="top: 90.6cqh; left: 42.2cqh;">
						<div class="line-draw"></div>
					</div>

					<!-- Oil-Squares -->

					<div id="oil-square-1" class="oil-square" style="top: 90.9cqh; left: 14.9cqh;">
					</div>

					<div id="oil-square-2" class="oil-square" style="top: 90.9cqh; left: 25.8cqh;">
					</div>

					<div id="oil-square-3" class="oil-square" style="top: 90.9cqh; left: 31.3cqh;">
					</div>

					<div id="oil-square-4" class="oil-square" style="top: 90.9cqh; left: 36.8cqh;">
					</div>

					<div id="oil-square-5" class="oil-square-final" style="top: 90.9cqh; left: 42.5cqh;">
					</div>

					<!-- NG-Crossoffs -->

					<div id="NG-Crossoff-1" class="ng-cross-off" style="top: 90.7cqh; left: 60.5cqh;">
						<div class="line-draw"></div>
					</div>
					<div id="NG-Crossoff-2" class="ng-cross-off" style="top: 90.7cqh; left: 65.8cqh;">
						<div class="line-draw"></div>
					</div>

					<!-- NG-Bonuses -->
					<div id="ng-bonus-1" class="ng-bonus" style="top: 90.6cqh; left: 60.3cqh;"></div>
					<div id="ng-bonus-2" class="ng-bonus" style="top: 90.6cqh; left: 65.9cqh;"></div>

					<!-- Round Tracker -->
					<div class="cross-off-round" style="top: 13.25cqh; left: 56.3cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-round" style="top: 13.25cqh; left: 59.6cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-round" style="top: 13.25cqh; left: 62.8cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-round" style="top: 13.25cqh; left: 66.1cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-round" style="top: 13.25cqh; left: 69.3cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-round" style="top: 16.4cqh; left: 57.7cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-round" style="top: 16.4cqh; left: 61.1cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-round" style="top: 16.4cqh; left: 64.4cqh;">
						<div class="line-draw"></div>
					</div>
					<div class="cross-off-round" style="top: 16.4cqh; left: 67.8cqh;">
						<div class="line-draw"></div>
					</div>

				</div>
			</div>

		</div>
		<div id="roll-area">
			<div class="roll-column roll-column-left">
				<div class="image-container" id="green-image"></div>
			</div>
			<div class="roll-column roll-column-middle">
				<div class="dice-container">
					<div class="die green" id="die1" data-value="6">
						<span class="pip"></span>
						<span class="pip"></span>
						<span class="pip"></span>
						<span class="pip"></span>
						<span class="pip"></span>
						<span class="pip"></span>
					</div>
					<div class="die white" id="die2" data-value="6">
						<span class="pip"></span>
						<span class="pip"></span>
						<span class="pip"></span>
						<span class="pip"></span>
						<span class="pip"></span>
						<span class="pip"></span>
					</div>
				</div>
				<button id="roll-button" class="loading">Roll</button>
			</div>
			<div class="roll-column roll-column-right">
				<div class="image-container" id="white-image"></div>
			</div>
		</div>
		<div id="tutorial-overlay" class="tutorial-overlay">
        <div id="tutorial-card" class="tutorial-card">
            <p id="tutorial-text"></p>
            <button id="tutorial-ok" class="menu-button">OK</button>
        </div>
    </div>
	</div>
	<div id="scoresheet" class="section">

		<div class="section-image-wrapper">
			<button id="finish-button" class="scoresheet-button">Finish</button>
			<button id="screenshot-button" class="scoresheet-button off-screen">Screenshot</button>
			<div id="final-score-bubble" class="final-score-bubble hidden"></div>
			<div id="screenshot-explainer" class="screenshot-explainer hidden-state">spoiler-free ></div>
			<img src="https://i.imgur.com/GHIUilC.png" alt="Scoresheet" class="section-image">
			<!-- Quartz Circle Clickers -->
			<div class="quartz-circle-clicker" style="top: 10.4cqh; left: calc(50% - 16.45cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="quartz-circle-clicker" style="top: 10.4cqh; left: calc(50% - 13.3cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="quartz-circle-clicker" style="top: 10.4cqh; left: calc(50% - 10cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="quartz-circle-clicker" style="top: 10.4cqh; left: calc(50% - 6.7cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="quartz-circle-clicker" style="top: 10.4cqh; left: calc(50% - 3.55cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="quartz-circle-clicker" style="top: 10.4cqh; left: calc(50% - 0.25cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="quartz-circle-clicker" style="top: 10.4cqh; left: calc(50% + 2.95cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="quartz-bonus-circle" style="top: 10.4cqh; left: calc(50% + 18.8cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<!-- Sandstone Circle Clickers -->
			<div class="sandstone-circle-clicker" style="top: 13.44cqh; left: calc(50% - 18.1cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="sandstone-circle-clicker" style="top: 13.44cqh; left: calc(50% - 14.8cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="sandstone-circle-clicker" style="top: 13.44cqh; left: calc(50% - 11.6cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="sandstone-circle-clicker" style="top: 13.44cqh; left: calc(50% - 8.3cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="sandstone-circle-clicker" style="top: 13.44cqh; left: calc(50% - 5.1cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="sandstone-circle-clicker" style="top: 13.44cqh; left: calc(50% - 1.8cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="sandstone-circle-clicker" style="top: 13.44cqh; left: calc(50% + 1.5cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="sandstone-circle-clicker" style="top: 13.44cqh; left: calc(50% + 4.8cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="sandstone-bonus-circle" style="top: 13.4cqh; left: calc(50% + 21.76cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<!-- Coal Circle Clickers -->
			<div class="coal-circle-clicker" style="top: 16.6cqh; left: calc(50% - 19.6cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="coal-circle-clicker" style="top: 16.6cqh; left: calc(50% - 16.4cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="coal-circle-clicker" style="top: 16.6cqh; left: calc(50% - 13.2cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="coal-circle-clicker" style="top: 16.6cqh; left: calc(50% - 9.95cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="coal-circle-clicker" style="top: 16.6cqh; left: calc(50% - 6.65cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="coal-circle-clicker" style="top: 16.6cqh; left: calc(50% - 3.45cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="coal-circle-clicker" style="top: 16.6cqh; left: calc(50% - 0.2cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="coal-circle-clicker" style="top: 16.6cqh; left: calc(50% + 3cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="coal-circle-clicker" style="top: 16.6cqh; left: calc(50% + 6.25cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="coal-bonus-circle" style="top: 16.6cqh; left: calc(50% + 24.9cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>

			<!-- Silver Circle Clickers -->
			<div class="silver-circle-clicker" style="top: 25.2cqh; left: calc(50% - 18.8cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="silver-circle-clicker" style="top: 25.2cqh; left: calc(50% - 15.6cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="silver-circle-clicker" style="top: 25.2cqh; left: calc(50% - 12.4cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="silver-circle-clicker" style="top: 25.2cqh; left: calc(50% - 9.15cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="silver-circle-clicker" style="top: 25.2cqh; left: calc(50% - 5.85cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="silver-circle-clicker" style="top: 25.2cqh; left: calc(50% - 2.6cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="silver-circle-clicker" style="top: 25.2cqh; left: calc(50% + 0.7cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="silver-circle-clicker" style="top: 25.2cqh; left: calc(50% + 3.95cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<!-- Diamond Circle Clickers -->
			<div class="diamond-circle-clicker" style="top: 33cqh; left: calc(50% - 18.8cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="diamond-circle-clicker" style="top: 33cqh; left: calc(50% - 15.6cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="diamond-circle-clicker" style="top: 33cqh; left: calc(50% - 12.4cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="diamond-circle-clicker" style="top: 33cqh; left: calc(50% - 9.15cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="diamond-circle-clicker" style="top: 33cqh; left: calc(50% - 5.85cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="diamond-circle-clicker" style="top: 33cqh; left: calc(50% - 2.6cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="diamond-circle-clicker" style="top: 33cqh; left: calc(50% + 0.7cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>

			<!-- Lapis Lazuli Circle Clickers -->
			<div class="lapis-circle-clicker" style="top: 40.9cqh; left: calc(50% - 18.8cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="lapis-circle-clicker" style="top: 40.9cqh; left: calc(50% - 15.6cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="lapis-circle-clicker" style="top: 40.9cqh; left: calc(50% - 12.4cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="lapis-circle-clicker" style="top: 40.9cqh; left: calc(50% - 9.15cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="lapis-circle-clicker" style="top: 40.9cqh; left: calc(50% - 5.85cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="lapis-circle-clicker" style="top: 40.9cqh; left: calc(50% - 2.6cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>

			<!-- Peridot Score Divs -->
			<div class="peridot-score peridot-score-1" style="top: 45.5cqh; left: calc(50% - 13cqh); transform: translate(-50%, -50%);"></div>
			<div class="peridot-score peridot-score-2" style="top: 45.5cqh; left: calc(50% - 8.27cqh); transform: translate(-50%, -50%);"></div>
			<div class="peridot-score peridot-score-3" style="top: 45.5cqh; left: calc(50% - 3.54cqh); transform: translate(-50%, -50%);"></div>
			<div class="peridot-score peridot-score-4" style="top: 45.5cqh; left: calc(50% + 1.19cqh); transform: translate(-50%, -50%);"></div>
			<div class="peridot-score peridot-score-5" style="top: 45.5cqh; left: calc(50% + 5.9cqh); transform: translate(-50%, -50%);"></div>

			<!-- Peridot Circle Clickers -->
			<div class="peridot-circle-clicker" style="top: 48.3cqh; left: calc(50% - 15.7cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="peridot-circle-clicker" style="top: 48.3cqh; left: calc(50% - 10.96cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="peridot-circle-clicker" style="top: 48.3cqh; left: calc(50% - 6.22cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="peridot-circle-clicker" style="top: 48.3cqh; left: calc(50% - 1.48cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="peridot-circle-clicker" style="top: 48.3cqh; left: calc(50% + 3.26cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>

			<!-- Topaz Circle Clickers -->
			<div class="topaz-circle-clicker" style="top: 56.5cqh; left: calc(50% - 18.8cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="topaz-circle-clicker" style="top: 56.5cqh; left: calc(50% - 15.6cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="topaz-circle-clicker" style="top: 56.5cqh; left: calc(50% - 12.4cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="topaz-circle-clicker" style="top: 56.5cqh; left: calc(50% - 9.15cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>

			<!-- Opal Circle Clickers -->
			<div class="opal-circle-clicker" style="top: 64.35cqh; left: calc(50% - 18.8cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="opal-circle-clicker" style="top: 64.35cqh; left: calc(50% - 15.6cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="opal-circle-clicker" style="top: 64.35cqh; left: calc(50% - 12.4cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="opal-circle-clicker" style="top: 64.35cqh; left: calc(50% - 9.15cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="opal-circle-clicker" style="top: 64.35cqh; left: calc(50% - 5.85cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>

			<!-- Amber Circle Clickers -->
			<div class="amber-circle-clicker" style="top: 72.2cqh; left: calc(50% - 18.8cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="amber-circle-clicker" style="top: 72.2cqh; left: calc(50% - 15.6cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>
			<div class="amber-circle-clicker" style="top: 72.2cqh; left: calc(50% - 12.4cqh); transform: translate(-50%, -50%);">
				<svg viewBox="0 0 40 40">
					<circle cx="20" cy="20" r="17.5" />
				</svg>
			</div>

			<!-- Q-S-C Score Readout -->
			<div id="q-s-c-score-readout" class="q-s-c-score-readout"></div>
			<!-- Silver Score Readout -->
			<div id="silver-score-readout" class="silver-score-readout"></div>
			<!-- Diamond Score Readout -->
			<div id="diamond-score-readout" class="diamond-score-readout"></div>
			<!-- Lapis Lazuli Score Readout -->
			<div id="lapis-score-readout" class="lapis-score-readout"></div>
			<!-- Peridot Score Readout -->
			<div id="peridot-score-readout" class="peridot-score-readout"></div>
			<!-- Topaz Score Readout -->
			<div id="topaz-score-readout" class="topaz-score-readout"></div>
			<!-- Opal Score Readout -->
			<div id="opal-score-readout" class="opal-score-readout"></div>
			<!-- Amber Score Readout -->
			<div id="amber-score-readout" class="amber-score-readout"></div>

		</div>
	</div>
</div>
</div>
<button id="left-button" class="nav-button"><svg xmlns="http://www.w3.org/2000/svg" height="4dvh" viewBox="0 -960 960 960" width="4dvh" fill="#FFFFFF">
		<path d="m313-440 224 224-57 56-320-320 320-320 57 56-224 224h487v80H313Z" />
	</svg></button>
<button id="right-button" class="nav-button"><svg xmlns="http://www.w3.org/2000/svg" height="4dvh" viewBox="0 -960 960 960" width="4dvh" fill="#FFFFFF">
		<path d="M647-440H160v-80h487L423-744l57-56 320 320-320 320-57-56 224-224Z" />
	</svg></button>
</body>
</div>
</div>
</div>
</div>
    
    <script>

        let currentView = 1;
let rollCounter = 0;
let selectedCells = new Set();
let committedCells = new Map();
let outlines = new Map();
let stateHistory = [];
let roundIndex = 0;
let diamondCount = 0;
let silverCount = 0;
let quartzCount = 0;
let sandstoneCount = 0;
let coalCount = 0;
let lapisCount = 0;
let peridotCount = 0;
let topazCount = 0;
let opalCount = 0;
let amberCount = 0;
let oilCount = 0;
let ngCount = 0;
let rowBonusCount = 0;
let columnBonusCount = 0;
let boulderBonusCount = 0;
let peridotScores = [0, 0, 0, 0, 0];
let quartzBonus = false;
let sandstoneBonus = false;
let coalBonus = false;
let isFirstRoll = true; // Track if it's the first roll of a game
let currentDigSheet = "dig-sheet-a";
let lockedGroups = [];
let gamePhase = "roll";
let bonusDigMode = false;
let oilBonusQueue = []; // Tracks oil indices granting bonuses (e.g., [2, 4, 5, 6, 7, 7])
const digSheetConfigs = {
	"dig-sheet-a": {
		unclickableCells: new Set([
			(1 - 1) * 10 + (1 - 1),
			(2 - 1) * 10 + (6 - 1),
			(2 - 1) * 10 + (10 - 1),
			(3 - 1) * 10 + (3 - 1),
			(4 - 1) * 10 + (1 - 1),
			(4 - 1) * 10 + (7 - 1),
			(4 - 1) * 10 + (10 - 1),
			(5 - 1) * 10 + (1 - 1),
			(5 - 1) * 10 + (2 - 1),
			(5 - 1) * 10 + (3 - 1),
			(5 - 1) * 10 + (4 - 1),
			(5 - 1) * 10 + (9 - 1),
			(5 - 1) * 10 + (10 - 1),
			(6 - 1) * 10 + (1 - 1),
			(6 - 1) * 10 + (3 - 1),
			(6 - 1) * 10 + (4 - 1),
			(6 - 1) * 10 + (5 - 1),
			(6 - 1) * 10 + (10 - 1),
			(7 - 1) * 10 + (4 - 1),
			(8 - 1) * 10 + (7 - 1),
			(8 - 1) * 10 + (9 - 1),
			(9 - 1) * 10 + (1 - 1),
			(9 - 1) * 10 + (5 - 1),
			(9 - 1) * 10 + (9 - 1),
			(10 - 1) * 10 + (1 - 1),
			(10 - 1) * 10 + (2 - 1),
			(10 - 1) * 10 + (3 - 1),
			(10 - 1) * 10 + (8 - 1),
			(10 - 1) * 10 + (9 - 1),
			(10 - 1) * 10 + (10 - 1)
		])
	},
	"dig-sheet-b": {
		unclickableCells: new Set([
			(1 - 1) * 10 + (1 - 1),
			(2 - 1) * 10 + (7 - 1),
			(3 - 1) * 10 + (3 - 1),
			(3 - 1) * 10 + (9 - 1),
			(3 - 1) * 10 + (10 - 1),
			(4 - 1) * 10 + (1 - 1),
			(4 - 1) * 10 + (10 - 1),
			(5 - 1) * 10 + (1 - 1),
			(5 - 1) * 10 + (2 - 1),
			(5 - 1) * 10 + (5 - 1),
			(5 - 1) * 10 + (8 - 1),
			(5 - 1) * 10 + (9 - 1),
			(5 - 1) * 10 + (10 - 1),
			(6 - 1) * 10 + (1 - 1),
			(7 - 1) * 10 + (4 - 1),
			(7 - 1) * 10 + (8 - 1),
			(7 - 1) * 10 + (9 - 1),
			(7 - 1) * 10 + (10 - 1),
			(8 - 1) * 10 + (2 - 1),
			(8 - 1) * 10 + (4 - 1),
			(8 - 1) * 10 + (6 - 1),
			(9 - 1) * 10 + (4 - 1),
			(9 - 1) * 10 + (10 - 1),
			(10 - 1) * 10 + (1 - 1),
			(10 - 1) * 10 + (3 - 1),
			(10 - 1) * 10 + (4 - 1),
			(10 - 1) * 10 + (5 - 1),
			(10 - 1) * 10 + (8 - 1),
			(10 - 1) * 10 + (9 - 1),
			(10 - 1) * 10 + (10 - 1)
		])
	},
	"dig-sheet-c": {
		unclickableCells: new Set([
			(1 - 1) * 10 + (1 - 1),
			(2 - 1) * 10 + (6 - 1),
			(3 - 1) * 10 + (3 - 1),
			(3 - 1) * 10 + (8 - 1),
			(3 - 1) * 10 + (9 - 1),
			(4 - 1) * 10 + (1 - 1),
			(4 - 1) * 10 + (9 - 1),
			(4 - 1) * 10 + (10 - 1),
			(5 - 1) * 10 + (1 - 1),
			(5 - 1) * 10 + (4 - 1),
			(5 - 1) * 10 + (6 - 1),
			(5 - 1) * 10 + (10 - 1),
			(6 - 1) * 10 + (4 - 1),
			(6 - 1) * 10 + (8 - 1),
			(6 - 1) * 10 + (10 - 1),
			(7 - 1) * 10 + (3 - 1),
			(7 - 1) * 10 + (4 - 1),
			(8 - 1) * 10 + (1 - 1),
			(8 - 1) * 10 + (2 - 1),
			(8 - 1) * 10 + (3 - 1),
			(8 - 1) * 10 + (7 - 1),
			(8 - 1) * 10 + (10 - 1),
			(9 - 1) * 10 + (5 - 1),
			(9 - 1) * 10 + (7 - 1),
			(10 - 1) * 10 + (1 - 1),
			(10 - 1) * 10 + (2 - 1),
			(10 - 1) * 10 + (7 - 1),
			(10 - 1) * 10 + (8 - 1),
			(10 - 1) * 10 + (9 - 1),
			(10 - 1) * 10 + (10 - 1)
		])
	},
	"dig-sheet-d": {
		unclickableCells: new Set([
			(1 - 1) * 10 + (1 - 1),
			(2 - 1) * 10 + (6 - 1),
			(3 - 1) * 10 + (3 - 1),
			(3 - 1) * 10 + (10 - 1),
			(4 - 1) * 10 + (1 - 1),
			(4 - 1) * 10 + (7 - 1),
			(4 - 1) * 10 + (8 - 1),
			(4 - 1) * 10 + (10 - 1),
			(5 - 1) * 10 + (1 - 1),
			(5 - 1) * 10 + (2 - 1),
			(5 - 1) * 10 + (3 - 1),
			(5 - 1) * 10 + (4 - 1),
			(5 - 1) * 10 + (8 - 1),
			(5 - 1) * 10 + (9 - 1),
			(5 - 1) * 10 + (10 - 1),
			(6 - 1) * 10 + (1 - 1),
			(6 - 1) * 10 + (2 - 1),
			(6 - 1) * 10 + (9 - 1),
			(6 - 1) * 10 + (10 - 1),
			(7 - 1) * 10 + (4 - 1),
			(7 - 1) * 10 + (7 - 1),
			(8 - 1) * 10 + (1 - 1),
			(9 - 1) * 10 + (1 - 1),
			(9 - 1) * 10 + (2 - 1),
			(9 - 1) * 10 + (3 - 1),
			(9 - 1) * 10 + (4 - 1),
			(9 - 1) * 10 + (6 - 1),
			(9 - 1) * 10 + (9 - 1),
			(10 - 1) * 10 + (1 - 1),
			(10 - 1) * 10 + (9 - 1)
		])
	},
	"dig-sheet-e": {
		unclickableCells: new Set([
			(2 - 1) * 10 + (1 - 1),
			(2 - 1) * 10 + (7 - 1),
			(2 - 1) * 10 + (10 - 1),
			(3 - 1) * 10 + (1 - 1),
			(3 - 1) * 10 + (2 - 1),
			(3 - 1) * 10 + (5 - 1),
			(3 - 1) * 10 + (10 - 1),
			(4 - 1) * 10 + (1 - 1),
			(4 - 1) * 10 + (2 - 1),
			(4 - 1) * 10 + (3 - 1),
			(5 - 1) * 10 + (1 - 1),
			(5 - 1) * 10 + (3 - 1),
			(5 - 1) * 10 + (9 - 1),
			(6 - 1) * 10 + (6 - 1),
			(6 - 1) * 10 + (8 - 1),
			(6 - 1) * 10 + (9 - 1),
			(7 - 1) * 10 + (2 - 1),
			(7 - 1) * 10 + (5 - 1),
			(7 - 1) * 10 + (6 - 1),
			(7 - 1) * 10 + (9 - 1),
			(7 - 1) * 10 + (10 - 1),
			(8 - 1) * 10 + (6 - 1),
			(8 - 1) * 10 + (10 - 1),
			(9 - 1) * 10 + (1 - 1),
			(9 - 1) * 10 + (3 - 1),
			(9 - 1) * 10 + (6 - 1),
			(9 - 1) * 10 + (8 - 1),
			(10 - 1) * 10 + (5 - 1),
			(10 - 1) * 10 + (6 - 1),
			(10 - 1) * 10 + (10 - 1)
		])
	},
	"dig-sheet-f": {
		unclickableCells: new Set([
			(2 - 1) * 10 + (3 - 1),
			(3 - 1) * 10 + (1 - 1),
			(3 - 1) * 10 + (9 - 1),
			(4 - 1) * 10 + (1 - 1),
			(4 - 1) * 10 + (2 - 1),
			(4 - 1) * 10 + (3 - 1),
			(4 - 1) * 10 + (4 - 1),
			(4 - 1) * 10 + (5 - 1),
			(5 - 1) * 10 + (1 - 1),
			(5 - 1) * 10 + (8 - 1),
			(5 - 1) * 10 + (10 - 1),
			(6 - 1) * 10 + (1 - 1),
			(6 - 1) * 10 + (3 - 1),
			(6 - 1) * 10 + (10 - 1),
			(7 - 1) * 10 + (6 - 1),
			(7 - 1) * 10 + (7 - 1),
			(8 - 1) * 10 + (2 - 1),
			(8 - 1) * 10 + (3 - 1),
			(8 - 1) * 10 + (7 - 1),
			(8 - 1) * 10 + (8 - 1),
			(8 - 1) * 10 + (9 - 1),
			(8 - 1) * 10 + (10 - 1),
			(9 - 1) * 10 + (2 - 1),
			(9 - 1) * 10 + (5 - 1),
			(10 - 1) * 10 + (1 - 1),
			(10 - 1) * 10 + (2 - 1),
			(10 - 1) * 10 + (3 - 1),
			(10 - 1) * 10 + (9 - 1),
			(10 - 1) * 10 + (10 - 1)
		])
	},
	"dig-sheet-g": {
		unclickableCells: new Set([
			(2 - 1) * 10 + (1 - 1),
			(3 - 1) * 10 + (1 - 1),
			(3 - 1) * 10 + (2 - 1),
			(3 - 1) * 10 + (5 - 1),
			(3 - 1) * 10 + (7 - 1),
			(3 - 1) * 10 + (10 - 1),
			(5 - 1) * 10 + (1 - 1),
			(5 - 1) * 10 + (3 - 1),
			(5 - 1) * 10 + (5 - 1),
			(5 - 1) * 10 + (9 - 1),
			(5 - 1) * 10 + (10 - 1),
			(6 - 1) * 10 + (1 - 1),
			(6 - 1) * 10 + (5 - 1),
			(7 - 1) * 10 + (5 - 1),
			(7 - 1) * 10 + (6 - 1),
			(7 - 1) * 10 + (9 - 1),
			(8 - 1) * 10 + (2 - 1),
			(8 - 1) * 10 + (4 - 1),
			(8 - 1) * 10 + (5 - 1),
			(8 - 1) * 10 + (6 - 1),
			(9 - 1) * 10 + (4 - 1),
			(9 - 1) * 10 + (5 - 1),
			(9 - 1) * 10 + (6 - 1),
			(9 - 1) * 10 + (10 - 1),
			(10 - 1) * 10 + (1 - 1),
			(10 - 1) * 10 + (6 - 1),
			(10 - 1) * 10 + (7 - 1),
			(10 - 1) * 10 + (8 - 1),
			(10 - 1) * 10 + (9 - 1),
			(10 - 1) * 10 + (10 - 1)
		])
	},
	"dig-sheet-h": {
		unclickableCells: new Set([
			(2 - 1) * 10 + (1 - 1),
			(2 - 1) * 10 + (5 - 1),
			(3 - 1) * 10 + (1 - 1),
			(3 - 1) * 10 + (2 - 1),
			(3 - 1) * 10 + (8 - 1),
			(3 - 1) * 10 + (9 - 1),
			(4 - 1) * 10 + (1 - 1),
			(4 - 1) * 10 + (6 - 1),
			(4 - 1) * 10 + (9 - 1),
			(4 - 1) * 10 + (10 - 1),
			(5 - 1) * 10 + (1 - 1),
			(5 - 1) * 10 + (2 - 1),
			(5 - 1) * 10 + (4 - 1),
			(5 - 1) * 10 + (9 - 1),
			(5 - 1) * 10 + (10 - 1),
			(6 - 1) * 10 + (2 - 1),
			(6 - 1) * 10 + (8 - 1),
			(6 - 1) * 10 + (9 - 1),
			(6 - 1) * 10 + (10 - 1),
			(7 - 1) * 10 + (2 - 1),
			(8 - 1) * 10 + (4 - 1),
			(8 - 1) * 10 + (7 - 1),
			(8 - 1) * 10 + (9 - 1),
			(8 - 1) * 10 + (10 - 1),
			(9 - 1) * 10 + (1 - 1),
			(9 - 1) * 10 + (9 - 1),
			(10 - 1) * 10 + (1 - 1),
			(10 - 1) * 10 + (2 - 1),
			(10 - 1) * 10 + (5 - 1),
			(10 - 1) * 10 + (6 - 1)
		])
	}
};
const digPatterns = {
	"roll-sheet-a": {
		green: {
			1: [
				[
					[
						[0, 0],
						[0, 1],
						[1, 1],
						[2, 1],
						[2, 2]
					]
				], // Option 1
				null // Option 2 (replace with pattern if available)
			],
			2: [
				[
					[
						[0, 0],
						[1, 0],
						[2, 0],
						[3, 0],
						[3, 1]
					]
				], // Option 1
				null // Option 2
			],
			3: [
				[
					[
						[0, 0],
						[1, 0],
						[1, 1],
						[1, 2],
						[2, 1]
					]
				], // Option 1
				null // Option 2
			],
			4: [
				[
					[
						[0, 1],
						[1, 0],
						[1, 1],
						[1, 2],
						[2, 1],
						[3, 1]
					]
				], // Option 1
				null // Option 2
			],
			5: [
				[
					[
						[0, 0],
						[1, 0],
						[2, 0],
						[2, 1],
						[2, 2],
						[3, 0]
					]
				], // Option 1
				null // Option 2
			],
			6: [
				[
					[
						[0, 0],
						[0, 1],
						[1, 0],
						[2, 0],
						[2, 1],
						[3, 1]
					]
				], // Option 1
				null // Option 2
			]
		},
		white: {
			1: [
				[
					[
						[0, 0],
						[1, 0],
						[2, 0],
						[3, 0]
					]
				], // Option 1: 1x4
				[
					[
						[0, 0],
						[0, 1],
						[1, 0],
						[1, 1]
					]
				] // Option 2: 2x2
			],
			2: [
				[
					[
						[0, 0],
						[1, 0],
						[1, 1],
						[2, 0],
						[3, 0]
					]
				], // Option 1
				[
					[
						[0, 0],
						[1, 0],
						[1, 1],
						[2, 1]
					]
				] // Option 2
			],
			3: [
				[
					[
						[0, 0],
						[0, 1],
						[0, 2],
						[1, 1],
						[2, 1]
					]
				], // Option 1: T-shape
				[
					[
						[0, 0],
						[1, 0]
					],
					[
						[0, 0],
						[1, 0]
					]
				] // Option 2: Two 1x2 verticals
			],
			4: [
				[[[0, 0]], [[0, 0]], [[0, 0]], [[0, 0]]], // Option 1: Four single cells
				null // Option 2 (replace if available)
			],
			5: [
				[
					[
						[0, 0],
						[0, 1],
						[1, 0]
					],
					[[0, 0]]
				], // Option 1: 3-cell + single cell
				null // Option 2
			],
			6: [
				[
					[
						[0, 0],
						[1, 0],
						[2, 0]
					],
					[
						[0, 0],
						[1, 0]
					]
				], // Option 1: 1x3 + 1x2
				null // Option 2
			]
		}
	},
	"roll-sheet-b": {
		green: {
			1: [
				[
					[
						[0, 0],
						[0, 1],
						[1, 0],
						[1, 1],
						[1, 2]
					]
				], // Option 1
				null // Option 2
			],
			2: [
				[
					[
						[0, 0],
						[1, 0],
						[2, 0],
						[3, 0],
						[4, 0]
					]
				], // Option 1
				null // Option 2
			],
			3: [
				[
					[
						[0, 0],
						[1, 0],
						[1, 1],
						[2, 1],
						[2, 2]
					]
				], // Option 1
				null // Option 2
			],
			4: [
				[
					[
						[0, 0],
						[0, 1],
						[1, 0],
						[2, 0],
						[3, 0],
						[3, 1]
					]
				], // Option 1
				null // Option 2
			],
			5: [
				[
					[
						[0, 1],
						[1, 1],
						[1, 2],
						[2, 0],
						[2, 1],
						[3, 1]
					]
				], // Option 1
				null // Option 2
			],
			6: [
				[
					[
						[0, 1],
						[1, 0],
						[1, 1],
						[1, 2],
						[2, 0],
						[2, 2]
					]
				], // Option 1
				null // Option 2
			]
		},
		white: {
			1: [
				[
					[
						[0, 0],
						[1, 0],
						[2, 0],
						[2, 1]
					]
				], // Option 1: L shape
				[
					[
						[0, 0],
						[0, 1],
						[1, 0],
						[1, 1]
					]
				] // Option 2: 2x2
			],
			2: [
				[
					[
						[0, 0],
						[1, 0],
						[2, 0],
						[2, 1],
						[3, 1]
					]
				], // Option 1
				[
					[
						[0, 0],
						[0, 1],
						[0, 2],
						[1, 1]
					]
				] // Option 2
			],
			3: [
				[
					[
						[0, 1],
						[1, 0],
						[1, 1],
						[1, 2],
						[2, 1]
					]
				], // Option 1: Plus Shape
				[
					[
						[0, 0],
						[1, 0]
					],
					[
						[0, 0],
						[1, 0]
					]
				] // Option 2: Two 1x2 verticals
			],
			4: [
				[[[0, 0]], [[0, 0]], [[0, 0]], [[0, 0]]], // Option 1: Four single cells
				null // Option 2
			],
			5: [
				[
					[
						[0, 0],
						[1, 0],
						[2, 0]
					],
					[[0, 0]]
				], // Option 1: 3-cell + single cell
				null // Option 2
			],
			6: [
				[
					[
						[0, 0],
						[0, 1],
						[1, 0]
					],
					[
						[0, 0],
						[1, 0]
					]
				], // Option 1: 3-cell + 1x2
				null // Option 2
			]
		}
	}
};
let currentRollSheet = "roll-sheet-a";
let gameMode = "free-play"; // Default to free-play

let tutorialMode = false;
let tutorialStep = 0;
let tutorialMessages = [
    "Welcome to Gem Getter Pro! Let's get you up to speed with how things work around here.",
    "There are 9 rounds in a game of Gem Getter Pro. You begin each round by rolling the dice. Ready to roll?",
    "Your dice roll reveals two or more possible dig patterns you can dig in your mine.",
    "Let's dig the green 5 pattern. Your first dig needs to touch the top row of the mine (just like real life!). Tap all the highlighted grid squares to create this dig pattern.",
    "Great job. Now you're ready to dig. Push the dig button to commit your dig to the grid!",
    "Cool, you collected some gems! Let's roll the dice again and dig some more!",
	"Dig patterns can be rotated or flipped however you like. Lets try it out on that green 6!",
    "You just got a bonus by digging all the way around that boulder. Nice work! Let's roll again.",
	"Some dig patterns let you dig multiple small shapes. Let's try out that white 6.",
    "First, let's tap to build the smaller shape",
    "Great, now tap within your shape again to lock it and prevent it from expanding further.",
    "Nice lock! Now we can select the other piece of the pattern. Go ahead and punch that in. Then tap the dig button.",
    "We've nearly reached the bottom! Roll again, and let's keep digging!",
	"Let's bust another boulder to collect that oil and natural gas! Dig the green 2 pattern.",
"You've collected enough oil for a bonus dig! Tap and dig another square.",
	"You dug out an entire row and got a bonus. So satisfying! Let's roll again.",
"You have a natural gas available. Tap the natural gas bonus to dig any pattern from the roll sheet (you don't have to dig the green 1 or the white 3).",
"Now you can dig any pattern available on the roll sheet. Instead of using the green 1, let's dig another green 2!",
	"Awesome. You're raking in the gems now! Go ahead and finish the last 4 rounds on your own. Each element has different scoring criteria, so keep an eye on your score sheet. Happy digging!",
	"You did it! Tap the finish button on the score sheet to see your final score."
];
let tutorialAllowedCells = []; // Per-step allowed indices (e.g., for step 3)
let tutorialPreRolls = [{ green: 5, white: 1 }, { green: 6, white: 2 }, { green: 3, white: 6 }, { green: 2, white: 5 }, { green: 1, white: 3 }, { green: 4, white: 5 }, { green: 3, white: 4 }, { green: 1, white: 2 }, { green: 5, white: 4 }];

const dailyDiceRolls = []; // Pre-computed rolls for daily challenge
const rollSheets = ["roll-sheet-a", "roll-sheet-b"];
const rollSheetImages = {
	"roll-sheet-a": "https://i.imgur.com/U3dEe1S.png",
	"roll-sheet-b": "https://i.imgur.com/Fh6WlRZ.png"
};
const digSheetBoulderConfigs = {
	"dig-sheet-a": [
		{ top: "30.9cqh", left: "44.4cqh" }, // Boulder 1
		{ top: "36.5cqh", left: "28cqh" }, // Boulder 2
		{ top: "42.1cqh", left: "49.8cqh" }, // Boulder 3
		{ top: "64.5cqh", left: "49.8cqh" }, // Boulder 4
		{ top: "70.1cqh", left: "39cqh" } // Boulder 5
	],
	"dig-sheet-b": [
		{ top: "30.9cqh", left: "50.0cqh" }, // Boulder 1
		{ top: "36.5cqh", left: "27.8cqh" }, // Boulder 2
		{ top: "47.7cqh", left: "38.9cqh" }, // Boulder 3
		{ top: "64.4cqh", left: "22.3cqh" }, // Boulder 4
		{ top: "64.4cqh", left: "44.5cqh" } // Boulder 5
	],
	"dig-sheet-c": [
		{ top: "30.9cqh", left: "44.5cqh" }, // 31.1 - 0.2, 44.7 - 0.2
		{ top: "36.5cqh", left: "27.8cqh" }, // 36.7 - 0.2, 28 - 0.2
		{ top: "47.7cqh", left: "44.5cqh" }, // 47.9 - 0.2, 44.7 - 0.2
		{ top: "53.2cqh", left: "55.6cqh" }, // 53.4 - 0.2, 55.8 - 0.2
		{ top: "70.0cqh", left: "38.9cqh" } // 70.2 - 0.2, 39.1 - 0.2
	],
	"dig-sheet-d": [
		{ top: "30.9cqh", left: "44.5cqh" }, // 31.1 - 0.2, 44.7 - 0.2
		{ top: "36.5cqh", left: "27.8cqh" }, // 36.7 - 0.2, 28 - 0.2
		{ top: "58.8cqh", left: "33.4cqh" }, // 59 - 0.2, 33.6 - 0.2
		{ top: "58.8cqh", left: "50.0cqh" }, // 59 - 0.2, 50.2 - 0.2
		{ top: "70.0cqh", left: "44.5cqh" } // 70.2 - 0.2, 44.7 - 0.2
	],
	"dig-sheet-e": [
		{ top: "30.9cqh", left: "50.0cqh" }, // 31.1 - 0.2, 50.2 - 0.2
		{ top: "36.5cqh", left: "38.9cqh" }, // 36.7 - 0.2, 39.1 - 0.2
		{ top: "58.8cqh", left: "22.3cqh" }, // 59 - 0.2, 22.5 - 0.2
		{ top: "70.0cqh", left: "27.8cqh" }, // 70.2 - 0.2, 28 - 0.2
		{ top: "70.0cqh", left: "55.6cqh" } // 70.2 - 0.2, 55.8 - 0.2
	],
	"dig-sheet-f": [
		{ top: "30.9cqh", left: "27.8cqh" }, // 31.1 - 0.2, 28 - 0.2
		{ top: "36.5cqh", left: "61.1cqh" }, // 36.7 - 0.2, 61.3 - 0.2
		{ top: "47.7cqh", left: "55.6cqh" }, // 47.9 - 0.2, 55.8 - 0.2
		{ top: "53.2cqh", left: "27.8cqh" }, // 53.4 - 0.2, 28 - 0.2
		{ top: "70.0cqh", left: "38.9cqh" } // 70.2 - 0.2, 39.1 - 0.2
	],
	"dig-sheet-g": [
		{ top: "36.5cqh", left: "38.9cqh" }, // 36.7 - 0.2, 39.1 - 0.2
		{ top: "36.5cqh", left: "50.0cqh" }, // 36.7 - 0.2, 50.2 - 0.2
		{ top: "47.7cqh", left: "27.8cqh" }, // 47.9 - 0.2, 28 - 0.2
		{ top: "58.8cqh", left: "61.1cqh" }, // 59 - 0.2, 61.3 - 0.2
		{ top: "64.4cqh", left: "22.3cqh" } // 64.6 - 0.2, 22.5 - 0.2
	],
	"dig-sheet-h": [
		{ top: "30.9cqh", left: "38.9cqh" }, // 31.1 - 0.2, 39.1 - 0.2
		{ top: "42.1cqh", left: "44.5cqh" }, // 42.3 - 0.2, 44.7 - 0.2
		{ top: "47.7cqh", left: "33.4cqh" }, // 47.9 - 0.2, 33.6 - 0.2
		{ top: "64.4cqh", left: "33.4cqh" }, // 64.6 - 0.2, 33.6 - 0.2
		{ top: "64.4cqh", left: "50.0cqh" } // 64.6 - 0.2, 50.2 - 0.2
	]
};

const coordinates = {
	"dig-sheet-a": {
		quartz: {
			grid: [
				{ row: 1, col: 4 },
				{ row: 1, col: 8 },
				{ row: 2, col: 3 },
				{ row: 2, col: 9 },
				{ row: 3, col: 9 },
				{ row: 4, col: 8 }
			],
			boulder: [],
			row: [{ index: 5, count: 1 }],
			column: []
		},
		sandstone: {
			grid: [
				{ row: 4, col: 2 },
				{ row: 4, col: 4 },
				{ row: 5, col: 5 },
				{ row: 5, col: 7 },
				{ row: 7, col: 3 },
				{ row: 7, col: 7 },
				{ row: 7, col: 9 }
			],
			boulder: [],
			row: [{ index: 7, count: 1 }],
			column: []
		},
		coal: {
			grid: [
				{ row: 8, col: 1 },
				{ row: 8, col: 4 },
				{ row: 8, col: 6 },
				{ row: 8, col: 10 },
				{ row: 9, col: 3 },
				{ row: 9, col: 6 },
				{ row: 9, col: 8 },
				{ row: 10, col: 4 }
			],
			boulder: [],
			row: [],
			column: [{ index: 5, count: 1 }]
		},
		silver: {
			grid: [
				{ row: 1, col: 2 },
				{ row: 1, col: 6 },
				{ row: 2, col: 2 }
			],
			boulder: [{ index: 3, count: 2 }],
			row: [{ index: 6, count: 1 }],
			column: [
				{ index: 5, count: 1 },
				{ index: 7, count: 1 }
			]
		},
		diamond: {
			grid: [
				{ row: 6, col: 2 },
				{ row: 9, col: 2 },
				{ row: 9, col: 10 }
			],
			boulder: [
				{ index: 1, count: 1 },
				{ index: 2, count: 1 }
			],
			row: [{ index: 9, count: 1 }],
			column: [{ index: 9, count: 1 }]
		},
		lapis: {
			grid: [
				{ row: 2, col: 7 },
				{ row: 3, col: 1 },
				{ row: 6, col: 8 },
				{ row: 7, col: 1 }
			],
			boulder: [],
			row: [{ index: 3, count: 1 }],
			column: [{ index: 10, count: 1 }]
		},
		peridot: {
			grid: [
				{ row: 6, col: 6 },
				{ row: 7, col: 10 }
			],
			boulder: [],
			row: [
				{ index: 1, count: 1 },
				{ index: 8, count: 1 }
			],
			column: [{ index: 1, count: 1 }]
		},
		topaz: {
			grid: [
				{ row: 1, col: 10 },
				{ row: 10, col: 7 }
			],
			boulder: [],
			row: [{ index: 4, count: 1 }],
			column: [{ index: 4, count: 1 }]
		},
		opal: {
			grid: [
				{ row: 3, col: 10 },
				{ row: 4, col: 5 },
				{ row: 7, col: 5 }
			],
			boulder: [],
			row: [{ index: 10, count: 1 }],
			column: [{ index: 8, count: 1 }]
		},
		amber: {
			grid: [{ row: 3, col: 6 }],
			boulder: [{ index: 5, count: 1 }],
			row: [],
			column: [{ index: 3, count: 1 }]
		},
		oil: {
			grid: [
				{ row: 3, col: 4 },
				{ row: 5, col: 8 },
				{ row: 8, col: 2 }
			],
			boulder: [{ index: 4, count: 1 }],
			row: [
				{ index: 2, count: 1 },
				{ index: 7, count: 1 }
			],
			column: [{ index: 6, count: 1 }]
		},
		ng: {
			grid: [],
			boulder: [{ index: 4, count: 1 }],
			row: [],
			column: [{ index: 2, count: 1 }]
		}
	},
	"dig-sheet-b": {
		quartz: {
			grid: [
				{ row: 1, col: 2 },
				{ row: 1, col: 3 },
				{ row: 1, col: 9 },
				{ row: 2, col: 6 },
				{ row: 3, col: 4 },
				{ row: 4, col: 5 }
			],
			boulder: [],
			row: [{ index: 4, count: 1 }],
			column: []
		},
		sandstone: {
			grid: [
				{ row: 4, col: 2 },
				{ row: 4, col: 4 },
				{ row: 4, col: 7 },
				{ row: 5, col: 3 },
				{ row: 5, col: 7 },
				{ row: 7, col: 5 }
			],
			boulder: [],
			row: [
				{ index: 6, count: 1 },
				{ index: 6, count: 1 }
			],
			column: []
		},
		coal: {
			grid: [
				{ row: 6, col: 2 },
				{ row: 6, col: 4 },
				{ row: 6, col: 9 },
				{ row: 7, col: 6 },
				{ row: 8, col: 3 },
				{ row: 8, col: 7 },
				{ row: 9, col: 8 },
				{ row: 10, col: 6 }
			],
			boulder: [{ index: 5, count: 1 }],
			row: [],
			column: []
		},
		silver: {
			grid: [
				{ row: 1, col: 5 },
				{ row: 1, col: 10 },
				{ row: 2, col: 8 },
				{ row: 5, col: 6 },
				{ row: 8, col: 1 },
				{ row: 9, col: 5 }
			],
			boulder: [],
			row: [{ index: 10, count: 1 }],
			column: [{ index: 6, count: 1 }]
		},
		diamond: {
			grid: [
				{ row: 4, col: 9 },
				{ row: 8, col: 10 }
			],
			boulder: [
				{ index: 1, count: 1 },
				{ index: 2, count: 1 },
				{ index: 4, count: 1 }
			],
			row: [],
			column: [
				{ index: 5, count: 1 },
				{ index: 10, count: 1 }
			]
		},
		lapis: {
			grid: [
				{ row: 2, col: 5 },
				{ row: 3, col: 1 },
				{ row: 6, col: 6 },
				{ row: 7, col: 1 }
			],
			boulder: [],
			row: [{ index: 1, count: 1 }],
			column: [{ index: 8, count: 1 }]
		},
		peridot: {
			grid: [
				{ row: 6, col: 10 },
				{ row: 8, col: 9 },
				{ row: 9, col: 7 }
			],
			boulder: [],
			row: [{ index: 2, count: 1 }],
			column: [{ index: 1, count: 1 }]
		},
		topaz: {
			grid: [],
			boulder: [{ index: 3, count: 1 }],
			row: [{ index: 8, count: 1 }],
			column: [
				{ index: 3, count: 1 },
				{ index: 9, count: 1 }
			]
		},
		opal: {
			grid: [
				{ row: 2, col: 1 },
				{ row: 3, col: 6 }
			],
			boulder: [{ index: 5, count: 1 }],
			row: [{ index: 3, count: 1 }],
			column: [{ index: 2, count: 1 }]
		},
		amber: {
			grid: [{ row: 3, col: 8 }],
			boulder: [],
			row: [{ index: 9, count: 1 }],
			column: [{ index: 7, count: 1 }]
		},
		oil: {
			grid: [
				{ row: 1, col: 7 },
				{ row: 2, col: 3 },
				{ row: 6, col: 8 },
				{ row: 9, col: 3 }
			],
			boulder: [],
			row: [
				{ index: 5, count: 1 },
				{ index: 7, count: 1 }
			],
			column: [{ index: 4, count: 1 }]
		},
		ng: {
			grid: [{ row: 10, col: 2 }],
			boulder: [],
			row: [],
			column: [{ index: 6, count: 1 }]
		}
	},
	"dig-sheet-c": {
		quartz: {
			grid: [
				{ row: 1, col: 2 },
				{ row: 1, col: 9 },
				{ row: 2, col: 4 },
				{ row: 2, col: 9 },
				{ row: 3, col: 6 },
				{ row: 4, col: 7 }
			],
			boulder: [{ index: 1, count: 1 }],
			row: [],
			column: []
		},
		sandstone: {
			grid: [
				{ row: 4, col: 2 },
				{ row: 4, col: 6 },
				{ row: 5, col: 8 },
				{ row: 6, col: 3 },
				{ row: 6, col: 6 },
				{ row: 6, col: 9 },
				{ row: 7, col: 5 }
			],
			boulder: [],
			row: [{ index: 5, count: 1 }],
			column: []
		},
		coal: {
			grid: [
				{ row: 6, col: 7 },
				{ row: 7, col: 2 },
				{ row: 7, col: 7 },
				{ row: 8, col: 5 },
				{ row: 8, col: 8 },
				{ row: 8, col: 9 },
				{ row: 9, col: 3 },
				{ row: 10, col: 4 }
			],
			boulder: [],
			row: [],
			column: [{ index: 7, count: 1 }]
		},
		silver: {
			grid: [
				{ row: 1, col: 7 },
				{ row: 1, col: 10 },
				{ row: 2, col: 1 },
				{ row: 4, col: 4 },
				{ row: 5, col: 5 }
			],
			boulder: [],
			row: [{ index: 8, count: 1 }],
			column: [
				{ index: 8, count: 1 },
				{ index: 8, count: 1 }
			]
		},
		diamond: {
			grid: [
				{ row: 6, col: 1 },
				{ row: 9, col: 1 },
				{ row: 9, col: 10 }
			],
			boulder: [
				{ index: 2, count: 1 },
				{ index: 4, count: 1 },
				{ index: 5, count: 1 }
			],
			row: [],
			column: [{ index: 3, count: 1 }]
		},
		lapis: {
			grid: [
				{ row: 2, col: 7 },
				{ row: 3, col: 1 },
				{ row: 9, col: 6 }
			],
			boulder: [{ index: 1, count: 1 }],
			row: [{ index: 7, count: 1 }],
			column: [{ index: 6, count: 1 }]
		},
		peridot: {
			grid: [
				{ row: 5, col: 3 },
				{ row: 10, col: 6 }
			],
			boulder: [],
			row: [
				{ index: 1, count: 1 },
				{ index: 3, count: 1 }
			],
			column: [{ index: 9, count: 1 }]
		},
		topaz: {
			grid: [
				{ row: 3, col: 4 },
				{ row: 10, col: 3 }
			],
			boulder: [{ index: 3, count: 1 }],
			row: [{ index: 2, count: 1 }],
			column: []
		},
		opal: {
			grid: [
				{ row: 1, col: 5 },
				{ row: 4, col: 8 },
				{ row: 7, col: 1 },
				{ row: 9, col: 9 }
			],
			boulder: [],
			row: [],
			column: [{ index: 2, count: 1 }]
		},
		amber: {
			grid: [{ row: 7, col: 10 }],
			boulder: [],
			row: [{ index: 9, count: 1 }],
			column: [{ index: 4, count: 1 }]
		},
		oil: {
			grid: [
				{ row: 2, col: 3 },
				{ row: 3, col: 10 },
				{ row: 8, col: 4 }
			],
			boulder: [],
			row: [
				{ index: 4, count: 1 },
				{ index: 10, count: 1 }
			],
			column: [
				{ index: 1, count: 1 },
				{ index: 10, count: 1 }
			]
		},
		ng: {
			grid: [],
			boulder: [],
			row: [{ index: 6, count: 1 }],
			column: [{ index: 5, count: 1 }]
		}
	},
	"dig-sheet-d": {
		quartz: {
			grid: [
				{ row: 1, col: 3 },
				{ row: 1, col: 6 },
				{ row: 2, col: 1 },
				{ row: 2, col: 9 },
				{ row: 3, col: 4 },
				{ row: 3, col: 5 }
			],
			boulder: [],
			row: [{ index: 3, count: 1 }],
			column: []
		},
		sandstone: {
			grid: [
				{ row: 3, col: 7 },
				{ row: 4, col: 2 },
				{ row: 4, col: 6 },
				{ row: 5, col: 5 },
				{ row: 5, col: 7 },
				{ row: 6, col: 3 },
				{ row: 8, col: 2 }
			],
			boulder: [{ index: 3, count: 1 }],
			row: [],
			column: []
		},
		coal: {
			grid: [
				{ row: 7, col: 3 },
				{ row: 7, col: 10 },
				{ row: 8, col: 8 },
				{ row: 9, col: 7 },
				{ row: 9, col: 10 },
				{ row: 10, col: 5 },
				{ row: 10, col: 8 }
			],
			boulder: [],
			row: [{ index: 9, count: 1 }],
			column: [{ index: 1, count: 1 }]
		},
		silver: {
			grid: [
				{ row: 1, col: 2 },
				{ row: 1, col: 8 },
				{ row: 7, col: 6 },
				{ row: 9, col: 8 }
			],
			boulder: [],
			row: [
				{ index: 2, count: 1 },
				{ index: 5, count: 1 },
				{ index: 7, count: 1 }
			],
			column: [{ index: 6, count: 1 }]
		},
		diamond: {
			grid: [
				{ row: 7, col: 1 },
				{ row: 10, col: 2 },
				{ row: 10, col: 10 }
			],
			boulder: [
				{ index: 1, count: 1 },
				{ index: 2, count: 1 },
				{ index: 5, count: 1 }
			],
			row: [{ index: 1, count: 1 }],
			column: []
		},
		lapis: {
			grid: [
				{ row: 1, col: 5 },
				{ row: 6, col: 8 },
				{ row: 7, col: 9 },
				{ row: 8, col: 5 }
			],
			boulder: [],
			row: [],
			column: [
				{ index: 3, count: 1 },
				{ index: 7, count: 1 }
			]
		},
		peridot: {
			grid: [
				{ row: 8, col: 3 },
				{ row: 10, col: 6 }
			],
			boulder: [],
			row: [{ index: 3, count: 1 }],
			column: [
				{ index: 4, count: 1 },
				{ index: 10, count: 1 }
			]
		},
		topaz: {
			grid: [
				{ row: 4, col: 9 },
				{ row: 10, col: 3 }
			],
			boulder: [{ index: 3, count: 1 }],
			row: [{ index: 6, count: 1 }],
			column: []
		},
		opal: {
			grid: [
				{ row: 2, col: 3 },
				{ row: 3, col: 8 },
				{ row: 6, col: 6 }
			],
			boulder: [],
			row: [{ index: 4, count: 1 }],
			column: [{ index: 5, count: 1 }]
		},
		amber: {
			grid: [{ row: 2, col: 10 }],
			boulder: [{ index: 4, count: 1 }],
			row: [],
			column: [{ index: 2, count: 1 }]
		},
		oil: {
			grid: [
				{ row: 2, col: 7 },
				{ row: 3, col: 2 },
				{ row: 4, col: 4 }
			],
			boulder: [],
			row: [
				{ index: 7, count: 1 },
				{ index: 8, count: 1 },
				{ index: 10, count: 1 }
			],
			column: [{ index: 8, count: 1 }]
		},
		ng: {
			grid: [{ row: 8, col: 10 }],
			boulder: [],
			row: [],
			column: [{ index: 9, count: 1 }]
		}
	},
	"dig-sheet-e": {
		quartz: {
			grid: [
				{ row: 1, col: 2 },
				{ row: 1, col: 8 },
				{ row: 2, col: 4 },
				{ row: 2, col: 6 },
				{ row: 2, col: 9 },
				{ row: 3, col: 3 }
			],
			boulder: [],
			row: [{ index: 4, count: 1 }],
			column: []
		},
		sandstone: {
			grid: [
				{ row: 3, col: 7 },
				{ row: 4, col: 5 },
				{ row: 4, col: 6 },
				{ row: 4, col: 9 },
				{ row: 6, col: 3 },
				{ row: 6, col: 5 },
				{ row: 6, col: 7 }
			],
			boulder: [],
			row: [{ index: 6, count: 1 }],
			column: []
		},
		coal: {
			grid: [
				{ row: 7, col: 1 },
				{ row: 7, col: 4 },
				{ row: 8, col: 1 },
				{ row: 8, col: 8 },
				{ row: 8, col: 9 },
				{ row: 9, col: 5 },
				{ row: 10, col: 2 },
				{ row: 10, col: 7 }
			],
			boulder: [],
			row: [],
			column: [{ index: 4, count: 1 }]
		},
		silver: {
			grid: [
				{ row: 1, col: 5 },
				{ row: 1, col: 9 },
				{ row: 5, col: 8 },
				{ row: 9, col: 7 },
				{ row: 10, col: 8 }
			],
			boulder: [],
			row: [{ index: 3, count: 1 }],
			column: [
				{ index: 4, count: 1 },
				{ index: 6, count: 1 }
			]
		},
		diamond: {
			grid: [
				{ row: 5, col: 2 },
				{ row: 10, col: 1 }
			],
			boulder: [
				{ index: 1, count: 1 },
				{ index: 2, count: 1 },
				{ index: 3, count: 1 },
				{ index: 4, count: 1 }
			],
			row: [],
			column: [{ index: 10, count: 1 }]
		},
		lapis: {
			grid: [
				{ row: 1, col: 1 },
				{ row: 4, col: 8 },
				{ row: 5, col: 4 }
			],
			boulder: [],
			row: [{ index: 5, count: 1 }],
			column: [
				{ index: 2, count: 1 },
				{ index: 8, count: 1 }
			]
		},
		peridot: {
			grid: [
				{ row: 7, col: 7 },
				{ row: 10, col: 3 }
			],
			boulder: [{ index: 5, count: 1 }],
			row: [{ index: 8, count: 1 }],
			column: [{ index: 9, count: 1 }]
		},
		topaz: {
			grid: [
				{ row: 1, col: 4 },
				{ row: 5, col: 6 },
				{ row: 8, col: 3 }
			],
			boulder: [],
			row: [{ index: 10, count: 1 }],
			column: []
		},
		opal: {
			grid: [
				{ row: 5, col: 10 },
				{ row: 8, col: 5 },
				{ row: 9, col: 4 }
			],
			boulder: [],
			row: [{ index: 1, count: 1 }],
			column: [{ index: 7, count: 1 }]
		},
		amber: {
			grid: [
				{ row: 6, col: 10 },
				{ row: 9, col: 10 }
			],
			boulder: [],
			row: [],
			column: [{ index: 5, count: 1 }]
		},
		oil: {
			grid: [
				{ row: 1, col: 10 },
				{ row: 2, col: 3 },
				{ row: 6, col: 2 }
			],
			boulder: [],
			row: [
				{ index: 2, count: 1 },
				{ index: 7, count: 1 },
				{ index: 9, count: 1 }
			],
			column: [{ index: 3, count: 1 }]
		},
		ng: {
			grid: [{ row: 10, col: 9 }],
			boulder: [],
			row: [],
			column: [{ index: 1, count: 1 }]
		}
	},
	"dig-sheet-f": {
		quartz: {
			grid: [
				{ row: 1, col: 2 },
				{ row: 1, col: 10 },
				{ row: 2, col: 4 },
				{ row: 2, col: 7 },
				{ row: 3, col: 2 },
				{ row: 3, col: 10 }
			],
			boulder: [],
			row: [{ index: 4, count: 1 }],
			column: []
		},
		sandstone: {
			grid: [
				{ row: 3, col: 6 },
				{ row: 5, col: 4 },
				{ row: 5, col: 6 },
				{ row: 5, col: 9 },
				{ row: 6, col: 2 },
				{ row: 6, col: 4 },
				{ row: 6, col: 7 }
			],
			boulder: [],
			row: [{ index: 6, count: 1 }],
			column: []
		},
		coal: {
			grid: [
				{ row: 6, col: 9 },
				{ row: 7, col: 1 },
				{ row: 7, col: 5 },
				{ row: 9, col: 4 },
				{ row: 9, col: 6 },
				{ row: 9, col: 8 },
				{ row: 10, col: 4 },
				{ row: 10, col: 8 }
			],
			boulder: [],
			row: [],
			column: [{ index: 1, count: 1 }]
		},
		silver: {
			grid: [
				{ row: 1, col: 5 },
				{ row: 2, col: 6 },
				{ row: 4, col: 7 },
				{ row: 6, col: 6 },
				{ row: 7, col: 3 }
			],
			boulder: [{ index: 4, count: 1 }],
			row: [{ index: 3, count: 1 }],
			column: [{ index: 9, count: 1 }]
		},
		diamond: {
			grid: [
				{ row: 9, col: 1 },
				{ row: 9, col: 10 }
			],
			boulder: [
				{ index: 1, count: 1 },
				{ index: 3, count: 1 },
				{ index: 5, count: 1 }
			],
			row: [{ index: 2, count: 1 }],
			column: [{ index: 8, count: 1 }]
		},
		lapis: {
			grid: [
				{ row: 1, col: 1 },
				{ row: 1, col: 7 },
				{ row: 9, col: 9 },
				{ row: 10, col: 6 }
			],
			boulder: [{ index: 4, count: 1 }],
			row: [],
			column: [{ index: 6, count: 1 }]
		},
		peridot: {
			grid: [
				{ row: 5, col: 5 },
				{ row: 8, col: 4 }
			],
			boulder: [],
			row: [{ index: 1, count: 1 }],
			column: [
				{ index: 7, count: 1 },
				{ index: 10, count: 1 }
			]
		},
		topaz: {
			grid: [
				{ row: 1, col: 9 },
				{ row: 7, col: 8 }
			],
			boulder: [],
			row: [{ index: 7, count: 1 }],
			column: [{ index: 5, count: 1 }]
		},
		opal: {
			grid: [
				{ row: 3, col: 5 },
				{ row: 4, col: 8 },
				{ row: 8, col: 1 }
			],
			boulder: [],
			row: [{ index: 6, count: 1 }],
			column: [{ index: 2, count: 1 }]
		},
		amber: {
			grid: [{ row: 7, col: 10 }],
			boulder: [{ index: 2, count: 1 }],
			row: [{ index: 5, count: 1 }],
			column: []
		},
		oil: {
			grid: [
				{ row: 2, col: 2 },
				{ row: 2, col: 9 },
				{ row: 5, col: 2 },
				{ row: 9, col: 3 }
			],
			boulder: [],
			row: [
				{ index: 8, count: 1 },
				{ index: 10, count: 1 }
			],
			column: [{ index: 3, count: 1 }]
		},
		ng: {
			grid: [],
			boulder: [],
			row: [{ index: 9, count: 1 }],
			column: [{ index: 4, count: 1 }]
		}
	},
	"dig-sheet-g": {
		quartz: {
			grid: [
				{ row: 1, col: 1 },
				{ row: 1, col: 6 },
				{ row: 2, col: 3 },
				{ row: 2, col: 8 },
				{ row: 3, col: 3 },
				{ row: 4, col: 7 }
			],
			boulder: [],
			row: [{ index: 2, count: 1 }],
			column: []
		},
		sandstone: {
			grid: [
				{ row: 4, col: 2 },
				{ row: 4, col: 4 },
				{ row: 5, col: 8 },
				{ row: 6, col: 6 },
				{ row: 6, col: 7 },
				{ row: 6, col: 9 },
				{ row: 7, col: 3 }
			],
			boulder: [{ index: 1, count: 1 }],
			row: [],
			column: []
		},
		coal: {
			grid: [
				{ row: 7, col: 1 },
				{ row: 7, col: 4 },
				{ row: 7, col: 8 },
				{ row: 8, col: 3 },
				{ row: 8, col: 8 },
				{ row: 8, col: 10 },
				{ row: 9, col: 1 },
				{ row: 9, col: 3 }
			],
			boulder: [],
			row: [],
			column: [{ index: 10, count: 1 }]
		},
		silver: {
			grid: [
				{ row: 1, col: 9 },
				{ row: 1, col: 10 },
				{ row: 4, col: 6 },
				{ row: 6, col: 4 },
				{ row: 7, col: 7 }
			],
			boulder: [],
			row: [
				{ index: 1, count: 1 },
				{ index: 3, count: 1 }
			],
			column: [{ index: 8, count: 1 }]
		},
		diamond: {
			grid: [
				{ row: 6, col: 10 },
				{ row: 9, col: 7 },
				{ row: 10, col: 5 }
			],
			boulder: [
				{ index: 2, count: 1 },
				{ index: 5, count: 1 }
			],
			row: [
				{ index: 8, count: 1 },
				{ index: 9, count: 1 }
			],
			column: []
		},
		lapis: {
			grid: [
				{ row: 2, col: 5 },
				{ row: 2, col: 7 },
				{ row: 6, col: 2 }
			],
			boulder: [],
			row: [
				{ index: 4, count: 1 },
				{ index: 6, count: 1 },
				{ index: 10, count: 1 }
			],
			column: []
		},
		peridot: {
			grid: [
				{ row: 5, col: 7 },
				{ row: 8, col: 1 }
			],
			boulder: [],
			row: [{ index: 2, count: 1 }],
			column: [
				{ index: 3, count: 1 },
				{ index: 7, count: 1 }
			]
		},
		topaz: {
			grid: [
				{ row: 1, col: 4 },
				{ row: 9, col: 9 }
			],
			boulder: [{ index: 3, count: 1 }],
			row: [],
			column: [{ index: 2, count: 1 }]
		},
		opal: {
			grid: [
				{ row: 3, col: 4 },
				{ row: 3, col: 9 }
			],
			boulder: [{ index: 1, count: 1 }],
			row: [{ index: 5, count: 1 }],
			column: [{ index: 5, count: 1 }]
		},
		amber: {
			grid: [{ row: 4, col: 1 }],
			boulder: [{ index: 4, count: 1 }],
			row: [],
			column: [{ index: 4, count: 1 }]
		},
		oil: {
			grid: [
				{ row: 1, col: 2 },
				{ row: 4, col: 9 },
				{ row: 7, col: 10 },
				{ row: 10, col: 2 }
			],
			boulder: [],
			row: [{ index: 7, count: 1 }],
			column: [
				{ index: 1, count: 1 },
				{ index: 9, count: 1 }
			]
		},
		ng: {
			grid: [{ row: 10, col: 4 }],
			boulder: [],
			row: [],
			column: [{ index: 6, count: 1 }]
		}
	},
	"dig-sheet-h": {
		quartz: {
			grid: [
				{ row: 1, col: 6 },
				{ row: 1, col: 9 },
				{ row: 2, col: 3 },
				{ row: 3, col: 7 },
				{ row: 4, col: 2 },
				{ row: 4, col: 5 }
			],
			boulder: [],
			row: [{ index: 2, count: 1 }],
			column: []
		},
		sandstone: {
			grid: [
				{ row: 4, col: 4 },
				{ row: 4, col: 8 },
				{ row: 5, col: 7 },
				{ row: 6, col: 3 },
				{ row: 6, col: 5 },
				{ row: 6, col: 7 },
				{ row: 7, col: 8 }
			],
			boulder: [],
			row: [{ index: 5, count: 1 }],
			column: []
		},
		coal: {
			grid: [
				{ row: 7, col: 4 },
				{ row: 7, col: 7 },
				{ row: 8, col: 2 },
				{ row: 9, col: 6 },
				{ row: 9, col: 8 },
				{ row: 10, col: 4 },
				{ row: 10, col: 9 }
			],
			boulder: [],
			row: [
				{ index: 10, count: 1 },
				{ index: 10, count: 1 }
			],
			column: []
		},
		silver: {
			grid: [
				{ row: 1, col: 4 },
				{ row: 2, col: 2 },
				{ row: 2, col: 9 },
				{ row: 3, col: 6 },
				{ row: 9, col: 2 },
				{ row: 9, col: 5 }
			],
			boulder: [{ index: 1, count: 1 }],
			row: [],
			column: [{ index: 1, count: 1 }]
		},
		diamond: {
			grid: [
				{ row: 6, col: 1 },
				{ row: 10, col: 10 }
			],
			boulder: [
				{ index: 3, count: 1 },
				{ index: 4, count: 1 },
				{ index: 5, count: 1 }
			],
			row: [{ index: 1, count: 1 }],
			column: [{ index: 6, count: 1 }]
		},
		lapis: {
			grid: [
				{ row: 2, col: 7 },
				{ row: 3, col: 10 },
				{ row: 8, col: 3 }
			],
			boulder: [],
			row: [{ index: 4, count: 1 }],
			column: [
				{ index: 2, count: 1 },
				{ index: 9, count: 1 }
			]
		},
		peridot: {
			grid: [
				{ row: 7, col: 1 },
				{ row: 7, col: 5 },
				{ row: 7, col: 9 }
			],
			boulder: [],
			row: [{ index: 3, count: 1 }],
			column: [{ index: 7, count: 1 }]
		},
		topaz: {
			grid: [{ row: 10, col: 3 }],
			boulder: [{ index: 2, count: 1 }],
			row: [],
			column: [
				{ index: 4, count: 1 },
				{ index: 8, count: 1 }
			]
		},
		opal: {
			grid: [
				{ row: 1, col: 2 },
				{ row: 2, col: 10 },
				{ row: 8, col: 6 }
			],
			boulder: [],
			row: [{ index: 6, count: 1 }],
			column: [{ index: 3, count: 1 }]
		},
		amber: {
			grid: [
				{ row: 3, col: 4 },
				{ row: 9, col: 10 }
			],
			boulder: [],
			row: [{ index: 7, count: 1 }],
			column: []
		},
		oil: {
			grid: [
				{ row: 1, col: 8 },
				{ row: 5, col: 6 },
				{ row: 10, col: 7 }
			],
			boulder: [{ index: 1, count: 1 }],
			row: [{ index: 9, count: 1 }],
			column: [
				{ index: 5, count: 1 },
				{ index: 10, count: 1 }
			]
		},
		ng: {
			grid: [{ row: 7, col: 10 }],
			boulder: [],
			row: [{ index: 8, count: 1 }],
			column: []
		}
	}
};

const digSheets = [
	"dig-sheet-a",
	"dig-sheet-b",
	"dig-sheet-c",
	"dig-sheet-d",
	"dig-sheet-e",
	"dig-sheet-f",
	"dig-sheet-g",
	"dig-sheet-h"
];
const digSheetOverlayImages = {
	"dig-sheet-a": "https://i.imgur.com/IehffPE.png",
	"dig-sheet-b": "https://i.imgur.com/qcEXPya.png",
	"dig-sheet-c": "https://i.imgur.com/Chip1Es.png",
	"dig-sheet-d": "https://i.imgur.com/qSwze1g.png",
	"dig-sheet-e": "https://i.imgur.com/kQbtrOJ.png",
	"dig-sheet-f": "https://i.imgur.com/gYvD1AJ.png",
	"dig-sheet-g": "https://i.imgur.com/Zieirfz.png",
	"dig-sheet-h": "https://i.imgur.com/c3YdwvM.png"
};
const digSheetBackgroundImages = {
	"dig-sheet-a": "https://i.imgur.com/Q6Rha58.png",
	"dig-sheet-b": "https://i.imgur.com/ViWEV4V.png",
	"dig-sheet-c": "https://i.imgur.com/tVO1usF.png",
	"dig-sheet-d": "https://i.imgur.com/2t23Tzn.png",
	"dig-sheet-e": "https://i.imgur.com/PNmnqT9.png",
	"dig-sheet-f": "https://i.imgur.com/82mPolH.png",
	"dig-sheet-g": "https://i.imgur.com/svQS3YG.png",
	"dig-sheet-h": "https://i.imgur.com/CJYKymQ.png"
};
const sounds = {
	pickaxe: {
		audio: [
			new Audio(
				"https://github.com/iiiDaNiii/gem-getter-pro-sound-effects/raw/refs/heads/main/Pickaxe1.mp3"
			),
			new Audio(
				"https://github.com/iiiDaNiii/gem-getter-pro-sound-effects/raw/refs/heads/main/Pickaxe2.mp3"
			),
			new Audio(
				"https://github.com/iiiDaNiii/gem-getter-pro-sound-effects/raw/refs/heads/main/Pickaxe3.mp3"
			)
		],
		lastIndex: -1
	},
	circle: {
		audio: [
			new Audio(
				"https://github.com/iiiDaNiii/gem-getter-pro-sound-effects/raw/refs/heads/main/Circle1.mp3"
			),
			new Audio(
				"https://github.com/iiiDaNiii/gem-getter-pro-sound-effects/raw/refs/heads/main/Circle2.mp3"
			),
			new Audio(
				"https://github.com/iiiDaNiii/gem-getter-pro-sound-effects/raw/refs/heads/main/Circle3.mp3"
			),
			new Audio(
				"https://github.com/iiiDaNiii/gem-getter-pro-sound-effects/raw/refs/heads/main/Circle4.mp3"
			)
		],
		lastIndex: -1
	},
	click: {
		audio: [
			new Audio(
				"https://github.com/iiiDaNiii/gem-getter-pro-sound-effects/raw/refs/heads/main/Click1.mp3"
			),
			new Audio(
				"https://github.com/iiiDaNiii/gem-getter-pro-sound-effects/raw/refs/heads/main/Click2.mp3"
			),
			new Audio(
				"https://github.com/iiiDaNiii/gem-getter-pro-sound-effects/raw/refs/heads/main/Click3.mp3"
			)
		],
		lastIndex: -1
	},
	crossOff: {
		audio: [
			new Audio(
				"https://github.com/iiiDaNiii/gem-getter-pro-sound-effects/raw/refs/heads/main/CrossOff1.mp3"
			),
			new Audio(
				"https://github.com/iiiDaNiii/gem-getter-pro-sound-effects/raw/refs/heads/main/CrossOff2.mp3"
			),
			new Audio(
				"https://github.com/iiiDaNiii/gem-getter-pro-sound-effects/raw/refs/heads/main/CrossOff3.mp3"
			),
			new Audio(
				"https://github.com/iiiDaNiii/gem-getter-pro-sound-effects/raw/refs/heads/main/CrossOff4.mp3"
			)
		],
		lastIndex: -1
	},
	bonus: {
		audio: [
			new Audio(
				"https://github.com/iiiDaNiii/gem-getter-pro-sound-effects/raw/refs/heads/main/bonus%20sound%203.mp3"
			),
			new Audio(
				"https://github.com/iiiDaNiii/gem-getter-pro-sound-effects/raw/refs/heads/main/bonus%20sound%204.mp3"
			)
		],
		lastIndex: -1
	},
	diceRollFirst: new Audio(
		"https://github.com/iiiDaNiii/gem-getter-pro-sound-effects/raw/refs/heads/main/Dice-hop%20roll%20slide%20once%201.1.mp3"
	),
	diceRollSubsequent: new Audio(
		"https://github.com/iiiDaNiii/gem-getter-pro-sound-effects/raw/refs/heads/main/Dice-hop%20roll%20slide.mp3"
	)
};

function normalizePolyomino(indices) {
	if (!indices || indices.length === 0) {
		console.log("normalizePolyomino: Empty or invalid indices");
		return [];
	}
	// Handle both grid indices (numbers) and pattern coords ([row,col])
	const coords =
		indices[0] && Array.isArray(indices[0])
			? indices.filter(
					(c) =>
						Array.isArray(c) &&
						c.length === 2 &&
						typeof c[0] === "number" &&
						typeof c[1] === "number"
			  )
			: indices
					.map((index) => {
						if (typeof index !== "number" || isNaN(index)) {
							console.log("normalizePolyomino: Invalid index", index);
							return null;
						}
						return [Math.floor(index / 10), index % 10];
					})
					.filter((c) => c !== null);
	if (coords.length === 0) {
		console.log("normalizePolyomino: No valid coordinates");
		return [];
	}
	// Translate to min row/col = 0
	const minRow = Math.min(...coords.map((c) => c[0]));
	const minCol = Math.min(...coords.map((c) => c[1]));
	let translated = coords.map((c) => [c[0] - minRow, c[1] - minCol]);
	// Generate transformations (4 rotations + horizontal flips)
	const transformations = [];
	let current = [...translated];
	for (let i = 0; i < 4; i++) {
		if (
			current.every(
				(c) =>
					Array.isArray(c) &&
					c.length === 2 &&
					typeof c[0] === "number" &&
					typeof c[1] === "number"
			)
		) {
			transformations.push(
				[...current].sort((a, b) => (a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]))
			);
		}
		// Horizontal flip
		const flipped = current.map((c) => [c[0], -c[1]]);
		const flipMinCol = Math.min(...flipped.map((c) => c[1])) || 0;
		const validFlipped = flipped
			.map((c) => [c[0], c[1] - flipMinCol])
			.filter(
				(c) =>
					Array.isArray(c) &&
					c.length === 2 &&
					typeof c[0] === "number" &&
					typeof c[1] === "number"
			);
		if (validFlipped.length === coords.length) {
			transformations.push(
				[...validFlipped].sort((a, b) =>
					a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]
				)
			);
		}
		// Rotate 90 clockwise: [r,c] -> [-c,r]
		current = current.map((c) => [-c[1], c[0]]);
		const minR = Math.min(...current.map((c) => c[0])) || 0;
		const minC = Math.min(...current.map((c) => c[1])) || 0;
		current = current.map((c) => [c[0] - minR, c[1] - minC]);
	}
	if (transformations.length === 0) {
		console.log("normalizePolyomino: No valid transformations");
		return [];
	}
	// Pick lexicographically smallest
	const canonical =
		transformations.sort((a, b) => {
			for (let i = 0; i < Math.min(a.length, b.length); i++) {
				if (!a[i] || !b[i]) return a.length - b.length;
				if (a[i][0] !== b[i][0]) return a[i][0] - b[i][0];
				if (a[i][1] !== b[i][1]) return a[i][1] - b[i][1];
			}
			return a.length - b.length;
		})[0] || [];
	console.log("normalizePolyomino result:", JSON.stringify(canonical));
	return canonical;
}

function isValidPattern() {
	if (bonusDigMode) {
		// In bonus dig mode, only allow a single cell
		return selectedCells.size === 1;
	}
	const greenValue =
		parseInt(document.getElementById("die1").getAttribute("data-value")) || 0;
	const whiteValue =
		parseInt(document.getElementById("die2").getAttribute("data-value")) || 0;
	console.log(
		`Checking pattern validity: green=${greenValue}, white=${whiteValue}, rollSheet=${currentRollSheet}`
	);
	if (!greenValue && !whiteValue) {
		console.log("No valid die values");
		return false;
	}
	// Check if NG is used (crossed-off but not used)
	const isNgUsed = ngCrossoffDivs.some(
		(div) =>
			div.classList.contains("crossed-off") && !div.classList.contains("used")
	);
	console.log("isNgUsed =", isNgUsed);
	// Collect player groups
	const playerGroups = [];
	const selectedVisited = new Set();
	for (let startIndex of Array.from(selectedCells)) {
		if (!selectedVisited.has(startIndex)) {
			const group = new Set();
			dfs(startIndex, group, selectedVisited, selectedCells);
			if (group.size > 0) playerGroups.push(Array.from(group));
		}
	}
	lockedGroups.forEach((group) => playerGroups.push(Array.from(group)));
	if (playerGroups.length === 0) {
		console.log("No player groups selected");
		return false;
	}
	console.log(
		"Player groups (indices):",
		playerGroups.map((g) => g.join(","))
	);
	const normalizedPlayer = playerGroups
		.map(normalizePolyomino)
		.filter((g) => g.length > 0)
		.sort((a, b) => {
			for (let i = 0; i < Math.min(a.length, b.length); i++) {
				if (!a[i] || !b[i]) return a.length - b.length;
				if (a[i][0] !== b[i][0]) return a[i][0] - b[i][0];
				if (a[i][1] !== b[i][1]) return a[i][1] - b[i][1];
			}
			return a.length - b.length;
		});
	if (normalizedPlayer.length === 0) {
		console.log("No valid normalized player groups");
		return false;
	}
	console.log("Normalized player groups:", JSON.stringify(normalizedPlayer));
	// Get patterns for current roll or all if NG used
	const allOptions = [];
	if (isNgUsed) {
		// Allow all patterns from current roll sheet
		for (let val = 1; val <= 6; val++) {
			if (digPatterns[currentRollSheet]?.green?.[val]) {
				allOptions.push(
					...digPatterns[currentRollSheet].green[val].filter(
						(p) =>
							p !== null &&
							p.every((g) =>
								g.every(
									(c) =>
										Array.isArray(c) &&
										c.length === 2 &&
										typeof c[0] === "number" &&
										typeof c[1] === "number"
								)
							)
					)
				);
			}
			if (digPatterns[currentRollSheet]?.white?.[val]) {
				allOptions.push(
					...digPatterns[currentRollSheet].white[val].filter(
						(p) =>
							p !== null &&
							p.every((g) =>
								g.every(
									(c) =>
										Array.isArray(c) &&
										c.length === 2 &&
										typeof c[0] === "number" &&
										typeof c[1] === "number"
								)
							)
					)
				);
			}
		}
	} else {
		// Normal validation
		if (greenValue && digPatterns[currentRollSheet]?.green?.[greenValue]) {
			allOptions.push(
				...digPatterns[currentRollSheet].green[greenValue].filter(
					(p) =>
						p !== null &&
						p.every((g) =>
							g.every(
								(c) =>
									Array.isArray(c) &&
									c.length === 2 &&
									typeof c[0] === "number" &&
									typeof c[1] === "number"
							)
						)
				)
			);
		}
		if (whiteValue && digPatterns[currentRollSheet]?.white?.[whiteValue]) {
			allOptions.push(
				...digPatterns[currentRollSheet].white[whiteValue].filter(
					(p) =>
						p !== null &&
						p.every((g) =>
							g.every(
								(c) =>
									Array.isArray(c) &&
									c.length === 2 &&
									typeof c[0] === "number" &&
									typeof c[1] === "number"
							)
						)
				)
			);
		}
	}
	console.log("Valid pattern options:", JSON.stringify(allOptions));
	if (allOptions.length === 0) {
		console.log("No valid pattern options available");
		return false;
	}
	// Check each option
	for (let option of allOptions) {
		if (option.length !== playerGroups.length) {
			console.log(`Option skipped (wrong group count): ${JSON.stringify(option)}`);
			continue;
		}
		const normalizedOption = option
			.map(normalizePolyomino)
			.filter((g) => g.length > 0)
			.sort((a, b) => {
				for (let i = 0; i < Math.min(a.length, b.length); i++) {
					if (!a[i] || !b[i]) return a.length - b.length;
					if (a[i][0] !== b[i][0]) return a[i][0] - b[i][0];
					if (a[i][1] !== b[i][1]) return a[i][1] - b[i][1];
				}
				return a.length - b.length;
			});
		if (normalizedOption.length !== normalizedPlayer.length) {
			console.log(
				`Normalized option skipped (wrong length): ${JSON.stringify(
					normalizedOption
				)}`
			);
			continue;
		}
		console.log("Normalized option:", JSON.stringify(normalizedOption));
		let match = true;
		for (let i = 0; i < normalizedPlayer.length; i++) {
			if (
				JSON.stringify(normalizedPlayer[i]) !== JSON.stringify(normalizedOption[i])
			) {
				console.log(
					`Mismatch at polyomino ${i}: player=${JSON.stringify(
						normalizedPlayer[i]
					)}, option=${JSON.stringify(normalizedOption[i])}`
				);
				match = false;
				break;
			}
		}
		if (match) {
			console.log("Pattern match found:", JSON.stringify(option));
			return true;
		}
	}
	console.log("No pattern match for player groups");
	return false;
}

const roundElements = [];
const diamondClickers = [];
const silverClickers = [];
const quartzClickers = [];
const sandstoneClickers = [];
const coalClickers = [];
const lapisClickers = [];
const peridotClickers = [];
const topazClickers = [];
const opalClickers = [];
const amberClickers = [];
const oilClickers = [];
const ngClickers = [];
const oilNgCrossOffClickers = [];
const silverScoreTable = {
	0: 0,
	1: 3,
	2: 4,
	3: 7,
	4: 6,
	5: 12,
	6: 18,
	7: 20,
	8: 24
};
const lapisScoreTable = {
	0: 0,
	1: 0,
	2: 6,
	3: 5,
	4: 15,
	5: 14,
	6: 25
};
function playSound(soundName) {
	let audio;
	if (sounds[soundName].audio) {
		const soundGroup = sounds[soundName];
		soundGroup.lastIndex = (soundGroup.lastIndex + 1) % soundGroup.audio.length;
		audio = soundGroup.audio[soundGroup.lastIndex];
	} else {
		audio = sounds[soundName];
	}
	if (audio) {
		audio.currentTime = 0;
		audio.volume =
			soundName === "click"
				? 0.4
				: soundName === "pickaxe"
				? 0.1
				: soundName === "bonus"
				? 0.25
				: 0.5;
		audio.play().catch((e) => console.log("Audio error:", e));
	}
}
function preloadImages() {
	const images = [];
	Object.values(imageMap["roll-sheet-a"].green).forEach((url) => {
		images.push(new Image());
		images[images.length - 1].src = url;
	});
	Object.values(imageMap["roll-sheet-a"].white).forEach((url) => {
		images.push(new Image());
		images[images.length - 1].src = url;
	});
	Object.values(imageMap["roll-sheet-b"].green).forEach((url) => {
		images.push(new Image());
		images[images.length - 1].src = url;
	});
	Object.values(imageMap["roll-sheet-b"].white).forEach((url) => {
		images.push(new Image());
		images[images.length - 1].src = url;
	});
	Object.values(digSheetBackgroundImages).forEach((url) => {
		images.push(new Image());
		images[images.length - 1].src = url;
	});
	Object.values(digSheetOverlayImages).forEach((url) => {
		images.push(new Image());
		images[images.length - 1].src = url;
	});
	Object.values(rollSheetImages).forEach((url) => {
		images.push(new Image());
		images[images.length - 1].src = url;
	});
	return Promise.all(
		images.map((img) => {
			return new Promise((resolve) => {
				img.onload = resolve;
				img.onerror = () => resolve();
			});
		})
	)
		.then(() => {
			isReady = true;
			rollButton.classList.remove("loading");
			rollButton.classList.add("loaded");
			digButton.classList.remove("loading");
			digButton.classList.add("loaded");
			const undoButton = document.getElementById("undo-button");
			if (undoButton) {
				undoButton.classList.remove("loading");
				undoButton.classList.add("loaded");
			}
			updateDigButtonState();
		})
		.catch((error) => {
			console.error("Image preloading failed:", error);
			isReady = true;
			updateDigButtonState();
		});
}
// Navigation Functions (Replaces all old scroll/return functions)
function getShiftAmount() {
  if (window.matchMedia("(min-aspect-ratio: 16/9)").matches) return 0; // No shift, all visible
  if (window.matchMedia("(min-aspect-ratio: 4/3)").matches) return 50; // Two panels, shift by half
  return 100; // Narrow, full viewport shift
}

function getMaxView() {
  if (window.matchMedia("(min-aspect-ratio: 16/9)").matches) return 0; // No views beyond 0
  if (window.matchMedia("(min-aspect-ratio: 4/3)").matches) return 1; // Views 0 (roll+dig) or 1 (dig+score)
  return 2; // Narrow: 0 (roll), 1 (dig), 2 (score)
}

function scrollLeft() {
  if (currentView > 0) {
    currentView--;
    const shift = getShiftAmount();
    const container = document.getElementById("game-container");
    container.style.transform = `translateX(-${currentView * shift}vw)`;
    updateButtons();
  }
}

function scrollRight() {
  const maxView = getMaxView();
  if (currentView < maxView) {
    currentView++;
    const shift = getShiftAmount();
    const container = document.getElementById("game-container");
    container.style.transform = `translateX(-${currentView * shift}vw)`;
    updateButtons();
  }
}

function updateButtons() {
  const leftButton = document.getElementById("left-button");
  const rightButton = document.getElementById("right-button");

  if (window.matchMedia("(min-aspect-ratio: 16/9)").matches) {
    // All three visible: Hide both arrows
    leftButton.classList.add("hidden");
    rightButton.classList.add("hidden");
    leftButton.style.display = "none";
    rightButton.style.display = "none";
  } else if (window.matchMedia("(min-aspect-ratio: 4/3)").matches) {
    // Two panels: Show/hide with explicit display to override
    if (currentView === 0) {
      leftButton.classList.add("hidden");
      leftButton.style.display = "none";
      rightButton.classList.remove("hidden");
      rightButton.style.display = "flex";
    } else { // view=1
      leftButton.classList.remove("hidden");
      leftButton.style.display = "flex";
      rightButton.classList.add("hidden");
      rightButton.style.display = "none";
    }
  } else {
    // Narrow: Show/hide with explicit display
    if (currentView === 0) {
      leftButton.classList.add("hidden");
      leftButton.style.display = "none";
      rightButton.classList.remove("hidden");
      rightButton.style.display = "flex";
    } else if (currentView === 2) {
      leftButton.classList.remove("hidden");
      leftButton.style.display = "flex";
      rightButton.classList.add("hidden");
      rightButton.style.display = "none";
    } else { // view=1, show both
      leftButton.classList.remove("hidden");
      leftButton.style.display = "flex";
      rightButton.classList.remove("hidden");
      rightButton.style.display = "flex";
    }
  }
}

// Rename setInitialView to updateView (for clarity, as it's now used on resize too)
function updateView() {
  const container = document.getElementById("game-container");
  const prevMaxView = getMaxView(); // Get old max before ratio check
  let needsReset = false;

  if (window.matchMedia("(min-aspect-ratio: 16/9)").matches) {
    container.style.width = "100%";
    currentView = 0; // Always 0, all visible
    container.style.transform = "translateX(0)";
    needsReset = true;
  } else if (window.matchMedia("(min-aspect-ratio: 4/3)").matches) {
    container.style.width = "200%";
    if (currentView > 1) currentView = 1; // Clamp to max=1 (dig+score if was on score)
    const shift = getShiftAmount();
    container.style.transform = `translateX(-${currentView * shift}vw)`;
    needsReset = prevMaxView !== 1; // Reset if ratio changed
  } else {
    container.style.width = "300%";
    if (currentView > 2) currentView = 2; // Unlikely, but clamp
    const shift = getShiftAmount();
    container.style.transform = `translateX(-${currentView * shift}vw)`;
    needsReset = prevMaxView !== 2; // Reset if ratio changed
  }

  updateButtons();
  // Optional: If ratio changed significantly, force reflow for smooth transition
  if (needsReset) {
    container.style.transition = "none"; // Temporarily disable for instant jump
    container.offsetHeight; // Reflow
    container.style.transition = "transform 0.5s ease"; // Re-enable
  }
}

const die1 = document.getElementById("die1");
const die2 = document.getElementById("die2");
const rollButton = document.getElementById("roll-button");
const digButton = document.getElementById("dig-button");
const greenImage = document.getElementById("green-image");
const whiteImage = document.getElementById("white-image");
let isReady = false;
let rollCount = 0;
const imageMap = {
	"roll-sheet-a": {
		green: {
			1: "https://i.imgur.com/NugZHpC.png",
			2: "https://i.imgur.com/8NPzkIj.png",
			3: "https://i.imgur.com/N8Ps2CK.png",
			4: "https://i.imgur.com/TtNDSwd.png",
			5: "https://i.imgur.com/oI2WRXC.png",
			6: "https://i.imgur.com/wns5xXP.png"
		},
		white: {
			1: "https://i.imgur.com/FuDH2yD.png",
			2: "https://i.imgur.com/9ElkVLT.png",
			3: "https://i.imgur.com/liSpdk7.png",
			4: "https://i.imgur.com/ejw4zrn.png",
			5: "https://i.imgur.com/wsFcuIL.png",
			6: "https://i.imgur.com/CwsIcnz.png"
		}
	},
	"roll-sheet-b": {
		green: {
			1: "https://i.imgur.com/MtOVS0P.png",
			2: "https://i.imgur.com/1Z3uPrg.png",
			3: "https://i.imgur.com/shOFUOJ.png",
			4: "https://i.imgur.com/4u3ghLR.png",
			5: "https://i.imgur.com/ZWhr6Dn.png",
			6: "https://i.imgur.com/3f2wOg7.png"
		},
		white: {
			1: "https://i.imgur.com/TeWqi5E.png",
			2: "https://i.imgur.com/OVyHWkz.png",
			3: "https://i.imgur.com/HGurD8z.png",
			4: "https://i.imgur.com/WdyyfSy.png",
			5: "https://i.imgur.com/QoazCJ3.png",
			6: "https://i.imgur.com/7YgS7iL.png"
		}
	}
};
function rollDice() {
    if (!isReady) return;
    const soundKey = isFirstRoll ? "diceRollFirst" : "diceRollSubsequent";
    console.log("Playing sound:", soundKey);
    playSound(soundKey);
    isFirstRoll = false;
    function animateRoll(timestamp) {
        if (!startTime) startTime = timestamp;
        const progress = (timestamp - startTime) / 500;
        if (progress <= 1) {
            die1.classList.add("jumping");
            if (progress >= 0.2) die2.classList.add("jumping");
            requestAnimationFrame(animateRoll);
        } else {
            die1.classList.remove("jumping");
            die2.classList.remove("jumping");
            let value1, value2;
            if (tutorialMode) {
                ({ green: value1, white: value2 } = tutorialPreRolls[rollCount] || { green: 6, white: 6 });
            } else if (gameMode === "daily-challenge") {
                if (rollCount >= 9) return;
                ({ green: value1, white: value2 } = dailyDiceRolls[rollCount]);
            } else {
                value1 = Math.floor(Math.random() * 6) + 1;
                value2 = Math.floor(Math.random() * 6) + 1;
            }
            rollCount++;
            die1.setAttribute("data-value", value1);
            die2.setAttribute("data-value", value2);
            console.log(
                `Roll result: green=${value1}, white=${value2}, rollCount=${rollCount}, rollSheet=${currentRollSheet}, tutorialStep=${tutorialStep}`
            );
            const sinkAndShow = (imageContainer, newImageSrc) => {
                imageContainer.classList.add("hide");
                setTimeout(() => {
                    imageContainer.classList.remove("hide");
                    imageContainer.innerHTML = `<img src="${newImageSrc}" alt="Die Image">`;
                    imageContainer.classList.add("show");
                }, 250);
            };
            sinkAndShow(greenImage, imageMap[currentRollSheet].green[value1]);
            setTimeout(
                () => {
                    sinkAndShow(whiteImage, imageMap[currentRollSheet].white[value2]);
                    // Delay advance after white image shows (total ~350ms post-dice + 1.5s)
                    if (tutorialMode && tutorialStep === 2) { // After roll post-OK on message1, advance to show message2 ("Your dice..."), increment to 3
                        advanceTutorialStep();
                        console.log("Advanced to step 3 after roll at step 2");
                    } else if (tutorialMode && tutorialStep === 6) { // After second roll post-OK on message5, advance to show message6 ("Dig patterns..."), increment to 7
                        advanceTutorialStep();
                        console.log("Advanced to step 7 after second roll at step 6");
                    } else if (tutorialMode && tutorialStep === 8) { // After third roll post-OK on message7, advance to show message8 ("Some dig patterns..."), increment to 9
                        advanceTutorialStep();
                        console.log("Advanced to step 9 after third roll at step 8");
                    } else if (tutorialMode && tutorialStep === 13) { // After fourth roll post-OK on message12, advance to show message13 (new 14: "Let's bust..."), increment to 14
                        advanceTutorialStep();
                        console.log("Advanced to step 14 after fourth roll at step 13");
                    } else if (tutorialMode && tutorialStep === 16) { // After fifth roll post-OK on message15 (16 1-based), advance to show message16 (17 1-based: "You have a natural gas...")
                        advanceTutorialStep();
                        console.log("Advanced to step 17 after fifth roll at step 16");
                    }
                },
                100
            );
            if (rollCount <= roundElements.length) {
                const nextRound = roundElements[rollCount - 1];
                if (nextRound && !nextRound.classList.contains("crossed-off")) {
                    nextRound.classList.add("crossed-off");
                }
            }
            stateHistory = [];
            gamePhase = "dig";
            updateNgCrossoffState();
            updateRollButtonState();
            updateDigButtonState();
            updateCellCursors();
        }
    }
    let startTime;
    requestAnimationFrame(animateRoll);
}
function updateQSCScore() {
	const sets = Math.min(quartzCount, sandstoneCount, coalCount);
	const setScoreTable = { 0: 0, 1: 1, 2: 4, 3: 9, 4: 15, 5: 23, 6: 33, 7: 45 };
	const score = setScoreTable[sets] || 0;
	const scoreReadout = document.getElementById("q-s-c-score-readout");
	if (scoreReadout) {
		scoreReadout.textContent = score === 0 ? "" : score;
	}
	updateFinalScore();
}
function updateQuartzClickers() {
	quartzClickers.forEach((clicker, index) => {
		if (index < quartzCount) {
			clicker.classList.add("circled");
			clicker.classList.remove("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else if (index === quartzCount) {
			clicker.classList.remove("circled", "disabled");
			clicker.style.pointerEvents = "auto";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else {
			clicker.classList.remove("circled");
			clicker.classList.add("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "0.5";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		}
	});
	const quartzBonusCircle = document.querySelector(".quartz-bonus-circle");
	if (quartzBonusCircle) {
		if (quartzCount >= 7 && !quartzBonus) {
			quartzBonus = true;
			quartzBonusCircle.classList.add("circled");
		} else if (quartzCount < 7 && quartzBonus) {
			quartzBonus = false;
			quartzBonusCircle.classList.remove("circled");
		}
	}
	updateQSCScore();
	updateFinalScore();
	console.log(
		"updateQuartzClickers: quartzCount =",
		quartzCount,
		"circled =",
		document.querySelectorAll(".quartz-circle-clicker.circled").length
	);
}

function updateSandstoneClickers() {
	sandstoneClickers.forEach((clicker, index) => {
		if (index < sandstoneCount) {
			clicker.classList.add("circled");
			clicker.classList.remove("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else if (index === sandstoneCount) {
			clicker.classList.remove("circled", "disabled");
			clicker.style.pointerEvents = "auto";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else {
			clicker.classList.remove("circled");
			clicker.classList.add("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "0.5";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		}
	});
	const sandstoneBonusCircle = document.querySelector(".sandstone-bonus-circle");
	if (sandstoneBonusCircle) {
		if (sandstoneCount >= 8 && !sandstoneBonus) {
			sandstoneBonus = true;
			sandstoneBonusCircle.classList.add("circled");
		} else if (sandstoneCount < 8 && sandstoneBonus) {
			sandstoneBonus = false;
			sandstoneBonusCircle.classList.remove("circled");
		}
	}
	updateQSCScore();
	updateFinalScore();
	console.log(
		"updateSandstoneClickers: sandstoneCount =",
		sandstoneCount,
		"circled =",
		document.querySelectorAll(".sandstone-circle-clicker.circled").length
	);
}

function updateCoalClickers() {
	coalClickers.forEach((clicker, index) => {
		if (index < coalCount) {
			clicker.classList.add("circled");
			clicker.classList.remove("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else if (index === coalCount) {
			clicker.classList.remove("circled", "disabled");
			clicker.style.pointerEvents = "auto";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else {
			clicker.classList.remove("circled");
			clicker.classList.add("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "0.5";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		}
	});
	const coalBonusCircle = document.querySelector(".coal-bonus-circle");
	if (coalBonusCircle) {
		if (coalCount >= 9 && !coalBonus) {
			coalBonus = true;
			coalBonusCircle.classList.add("circled");
		} else if (coalCount < 9 && coalBonus) {
			coalBonus = false;
			coalBonusCircle.classList.remove("circled");
		}
	}
	updateQSCScore();
	updateFinalScore();
	console.log(
		"updateCoalClickers: coalCount =",
		coalCount,
		"circled =",
		document.querySelectorAll(".coal-circle-clicker.circled").length
	);
}

function updateDiamondClickers() {
	diamondClickers.forEach((clicker, index) => {
		if (index < diamondCount) {
			clicker.classList.add("circled");
			clicker.classList.remove("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else if (index === diamondCount) {
			clicker.classList.remove("circled", "disabled");
			clicker.style.pointerEvents = "auto";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else {
			clicker.classList.remove("circled");
			clicker.classList.add("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "0.5";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		}
	});
	const diamondScore = diamondCount * 4;
	const scoreReadout = document.getElementById("diamond-score-readout");
	if (scoreReadout) {
		scoreReadout.textContent = diamondCount === 0 ? "" : diamondScore;
	}
	updateTopazClickers();
	updateFinalScore();
	console.log(
		"updateDiamondClickers: diamondCount =",
		diamondCount,
		"circled =",
		document.querySelectorAll(".diamond-circle-clicker.circled").length
	);
}

function updateSilverClickers() {
	silverClickers.forEach((clicker, index) => {
		if (index < silverCount) {
			clicker.classList.add("circled");
			clicker.classList.remove("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else if (index === silverCount) {
			clicker.classList.remove("circled", "disabled");
			clicker.style.pointerEvents = "auto";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else {
			clicker.classList.remove("circled");
			clicker.classList.add("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "0.5";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		}
	});
	const silverScore = silverScoreTable[silverCount] || 0;
	const scoreReadout = document.getElementById("silver-score-readout");
	if (scoreReadout) {
		scoreReadout.textContent = silverCount === 0 ? "" : silverScore;
	}
	updateTopazClickers();
	updateFinalScore();
	console.log(
		"updateSilverClickers: silverCount =",
		silverCount,
		"circled =",
		document.querySelectorAll(".silver-circle-clicker.circled").length
	);
}

function updateLapisClickers() {
	lapisClickers.forEach((clicker, index) => {
		if (index < lapisCount) {
			clicker.classList.add("circled");
			clicker.classList.remove("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else if (index === lapisCount) {
			clicker.classList.remove("circled", "disabled");
			clicker.style.pointerEvents = "auto";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else {
			clicker.classList.remove("circled");
			clicker.classList.add("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "0.5";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		}
	});
	const lapisScore = lapisScoreTable[lapisCount] || 0;
	const scoreReadout = document.getElementById("lapis-score-readout");
	if (scoreReadout) {
		scoreReadout.textContent = lapisCount === 0 ? "" : lapisScore;
	}
	updateFinalScore();
	console.log(
		"updateLapisClickers: lapisCount =",
		lapisCount,
		"circled =",
		document.querySelectorAll(".lapis-circle-clicker.circled").length
	);
}

function updatePeridotClickers() {
	peridotClickers.forEach((clicker, index) => {
		if (index < peridotCount) {
			clicker.classList.add("circled");
			clicker.classList.remove("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else if (index === peridotCount) {
			clicker.classList.remove("circled", "disabled");
			clicker.style.pointerEvents = "auto";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else {
			clicker.classList.remove("circled");
			clicker.classList.add("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "0.5";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		}
	});
	const scoreDivs = Array.from(document.querySelectorAll(".peridot-score"));
	let totalScore = 0;
	scoreDivs.forEach((div, index) => {
		if (index < peridotCount) {
			const score = parseInt(div.textContent) || 0;
			peridotScores[index] = score;
			totalScore += score;
		} else {
			peridotScores[index] = 0;
			div.textContent = "";
		}
	});
	const scoreReadout = document.getElementById("peridot-score-readout");
	if (scoreReadout) {
		scoreReadout.textContent = totalScore === 0 ? "" : totalScore;
	}
	updateFinalScore();
	console.log(
		"updatePeridotClickers: peridotCount =",
		peridotCount,
		"circled =",
		document.querySelectorAll(".peridot-circle-clicker.circled").length
	);
}

function updateTopazClickers() {
	topazClickers.forEach((clicker, index) => {
		if (index < topazCount) {
			clicker.classList.add("circled");
			clicker.classList.remove("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else if (index === topazCount) {
			clicker.classList.remove("circled", "disabled");
			clicker.style.pointerEvents = "auto";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else {
			clicker.classList.remove("circled");
			clicker.classList.add("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "0.5";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		}
	});
	const topazScore =
		topazCount > 0 && silverCount === 0 && diamondCount === 0
			? 0
			: topazCount * Math.max(silverCount, diamondCount);
	const scoreReadout = document.getElementById("topaz-score-readout");
	if (scoreReadout) {
		scoreReadout.textContent = topazCount === 0 ? "" : topazScore;
	}
	updateFinalScore();
	console.log(
		"updateTopazClickers: topazCount =",
		topazCount,
		"circled =",
		document.querySelectorAll(".topaz-circle-clicker.circled").length
	);
}

function updateOpalClickers() {
	opalClickers.forEach((clicker, index) => {
		if (index < opalCount) {
			clicker.classList.add("circled");
			clicker.classList.remove("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else if (index === opalCount) {
			clicker.classList.remove("circled", "disabled");
			clicker.style.pointerEvents = "auto";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else {
			clicker.classList.remove("circled");
			clicker.classList.add("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "0.5";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		}
	});
	const opalScore = opalCount * Math.max(rowBonusCount, columnBonusCount);
	const scoreReadout = document.getElementById("opal-score-readout");
	if (scoreReadout) {
		scoreReadout.textContent = opalCount === 0 ? "" : opalScore;
	}
	updateFinalScore();
	console.log(
		"updateOpalClickers: opalCount =",
		opalCount,
		"circled =",
		document.querySelectorAll(".opal-circle-clicker.circled").length
	);
}

function updateAmberClickers() {
	amberClickers.forEach((clicker, index) => {
		if (index < amberCount) {
			clicker.classList.add("circled");
			clicker.classList.remove("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else if (index === amberCount) {
			clicker.classList.remove("circled", "disabled");
			clicker.style.pointerEvents = "auto";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else {
			clicker.classList.remove("circled");
			clicker.classList.add("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "0.5";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		}
	});
	const amberScore = amberCount * 2 * boulderBonusCount;
	const scoreReadout = document.getElementById("amber-score-readout");
	if (scoreReadout) {
		scoreReadout.textContent = amberCount === 0 ? "" : amberScore;
	}
	updateFinalScore();
	console.log(
		"updateAmberClickers: amberCount =",
		amberCount,
		"circled =",
		document.querySelectorAll(".amber-circle-clicker.circled").length
	);
}

function updateOilClickers() {
	oilClickers.forEach((clicker, index) => {
		if (index < oilCount) {
			clicker.classList.add("circled");
			clicker.classList.remove("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else if (index === oilCount) {
			clicker.classList.remove("circled", "disabled");
			clicker.style.pointerEvents = "auto";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else {
			clicker.classList.remove("circled");
			clicker.classList.add("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "0.5";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		}
	});
	updateOilNgCrossOffClickers();
	console.log(
		"updateOilClickers: oilCount =",
		oilCount,
		"circled =",
		document.querySelectorAll(".oil-circle-clicker.circled").length
	);
}

function updateNgClickers() {
	ngClickers.forEach((clicker, index) => {
		if (index < ngCount) {
			clicker.classList.add("circled");
			clicker.classList.remove("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else if (index === ngCount) {
			clicker.classList.remove("circled", "disabled");
			clicker.style.pointerEvents = "auto";
			clicker.style.opacity = "1";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		} else {
			clicker.classList.remove("circled");
			clicker.classList.add("disabled");
			clicker.style.pointerEvents = "none";
			clicker.style.opacity = "0.5";
			const circle = clicker.querySelector("circle");
			if (circle) circle.setAttribute("stroke", "black");
		}
	});
	console.log(
		"updateNgClickers: ngCount =",
		ngCount,
		"circled =",
		document.querySelectorAll(".ng-circle-clicker.circled").length
	);
}

function updateNgCrossoffState() {
	ngCrossoffDivs.forEach((div, index) => {
		const isClickable =
			gamePhase === "dig" &&
			selectedCells.size === 0 &&
			lockedGroups.length === 0 &&
			index < ngCount &&
			!bonusDigMode;
		if (div.classList.contains("used")) {
			div.classList.add("crossed-off");
			div.classList.remove("clickable");
			div.style.pointerEvents = "none";
			div.style.opacity = "1";
		} else if (div.classList.contains("crossed-off")) {
			div.classList.remove("clickable");
			div.style.pointerEvents = "auto"; // Allow uncrossing before commit
			div.style.opacity = "1";
		} else if (isClickable) {
			div.classList.add("clickable");
			div.style.pointerEvents = "auto";
			div.style.opacity = "1";
		} else {
			div.classList.remove("clickable");
			div.style.pointerEvents = "none";
			div.style.opacity = "0.5";
		}
		// Show/hide and pulse ng-bonus if clickable
		const bonusDiv = ngBonusDivs[index];
		if (bonusDiv) {
			if (div.classList.contains("clickable")) {
				bonusDiv.style.display = "block";
				bonusDiv.classList.add("pulsing-ng-bonus");
			} else {
				bonusDiv.style.display = "none";
				bonusDiv.classList.remove("pulsing-ng-bonus");
			}
		}
	});
	console.log(
		"updateNgCrossoffState: ngCount =",
		ngCount,
		"gamePhase =",
		gamePhase,
		"selectedCells =",
		selectedCells.size,
		"lockedGroups =",
		lockedGroups.length,
		"bonusDigMode =",
		bonusDigMode
	);
}

function canClickOilNgCrossOff(index) {
	switch (index) {
		case 0:
			return oilClickers[1]?.classList.contains("circled");
		case 1:
			return oilClickers[3]?.classList.contains("circled");
		case 2:
			return oilClickers[4]?.classList.contains("circled");
		case 3:
			return oilClickers[5]?.classList.contains("circled");
		case 4:
			return oilClickers[6]?.classList.contains("circled");
		default:
			return false;
	}
}
function updateOilNgCrossOffClickers() {
	oilNgCrossOffClickers.forEach((clicker, index) => {
		if (
			clicker.classList.contains("crossed-off") ||
			canClickOilNgCrossOff(index)
		) {
			clicker.classList.remove("disabled");
			clicker.style.pointerEvents = "auto";
		} else {
			clicker.classList.add("disabled");
			clicker.style.pointerEvents = "none";
		}
	});
}
function updateFinalScore() {
	let finalScore = 0;
	finalScore +=
		parseInt(document.getElementById("diamond-score-readout")?.textContent) || 0;
	finalScore +=
		parseInt(document.getElementById("silver-score-readout")?.textContent) || 0;
	finalScore +=
		parseInt(document.getElementById("lapis-score-readout")?.textContent) || 0;
	finalScore +=
		parseInt(document.getElementById("peridot-score-readout")?.textContent) || 0;
	finalScore +=
		parseInt(document.getElementById("topaz-score-readout")?.textContent) || 0;
	finalScore +=
		parseInt(document.getElementById("opal-score-readout")?.textContent) || 0;
	finalScore +=
		parseInt(document.getElementById("amber-score-readout")?.textContent) || 0;
	finalScore +=
		parseInt(document.getElementById("q-s-c-score-readout")?.textContent) || 0;
	if (quartzBonus) finalScore += 6;
	if (sandstoneBonus) finalScore += 9;
	if (coalBonus) finalScore += 13;
	const finalScoreDiv = document.getElementById("final-score");
	if (finalScoreDiv && !finalScoreDiv.classList.contains("hidden-score")) {
		finalScoreDiv.textContent = finalScore === 0 ? "" : finalScore;
	}
}
function hasGameState() {
	return (
		selectedCells.size > 0 ||
		committedCells.size > 0 ||
		rollCount > 0 ||
		diamondCount > 0 ||
		silverCount > 0 ||
		quartzCount > 0 ||
		sandstoneCount > 0 ||
		coalCount > 0 ||
		lapisCount > 0 ||
		peridotCount > 0 ||
		topazCount > 0 ||
		opalCount > 0 ||
		amberCount > 0 ||
		oilCount > 0 ||
		ngCount > 0 ||
		rowBonusCount > 0 ||
		columnBonusCount > 0 ||
		boulderBonusCount > 0 ||
		document.querySelectorAll(".circle-clicker.circled").length > 0 ||
		document.querySelectorAll(".cross-off-clicker.crossed-off").length > 0 ||
		document.querySelectorAll(".oil-ng-cross-off-clicker.crossed-off").length >
			0 ||
		document.querySelectorAll(".cross-off-round.crossed-off").length > 0
	);
}
function resetGrid() {
    console.log("Resetting grid and all cross-off clickers");
    const grid = document.getElementById("grid");
    grid.querySelectorAll(".polyomino-svg").forEach((svg) => svg.remove());
    document.querySelectorAll(".cell").forEach((cell) => {
        cell.classList.remove("committed", "disabled", "no-pointer");
    });
    const unclickableCells = digSheetConfigs[currentDigSheet].unclickableCells;
    console.log(
        `Applying unclickable cells for ${currentDigSheet}:`,
        Array.from(unclickableCells)
    );
    requestAnimationFrame(() => {
        unclickableCells.forEach((index) => {
            const cell = document.querySelector(`.cell[data-index="${index}"]`);
            if (cell) cell.classList.add("disabled");
        });
        updateCellCursors();
    });
    committedCells.clear();
    selectedCells.clear();
    lockedGroups = [];
    outlines.clear();
    stateHistory = [];
    document
        .querySelectorAll(
            ".circle-clicker, .quartz-circle-clicker, .sandstone-circle-clicker, .coal-circle-clicker, .silver-circle-clicker, .diamond-circle-clicker, .lapis-circle-clicker, .peridot-circle-clicker, .topaz-circle-clicker, .opal-circle-clicker, .amber-circle-clicker, .oil-circle-clicker, .ng-circle-clicker"
        )
        .forEach((clicker) => {
            clicker.classList.remove("circled", "disabled");
            clicker.style.opacity = "1";
            clicker.style.pointerEvents = "auto";
            const circle = clicker.querySelector("circle");
            if (circle) {
                circle.setAttribute("stroke", "black");
                circle.setAttribute("stroke-dashoffset", "110");
            }
        });
    document.querySelectorAll(".cross-off-clicker").forEach((clicker) => {
        clicker.classList.remove("crossed-off");
        clicker.querySelector(".line-draw")?.classList.remove("crossed-off");
    });
    document
        .querySelectorAll(".oil-ng-cross-off-clicker")
        .forEach((clicker, index) => {
            clicker.classList.remove("crossed-off");
            clicker.querySelector(".line-draw")?.classList.remove("crossed-off");
            console.log(`Cleared oil/ng cross-off clicker ${index}`);
        });
    document.querySelectorAll(".cross-off-round").forEach((round, index) => {
        round.classList.remove("crossed-off");
        round.querySelector(".line-draw")?.classList.remove("crossed-off");
        console.log(
            `Cleared round cross-off ${index + 1} at position: top=${
                round.style.top
            }, left=${round.style.left}`
        );
    });
    document.querySelectorAll(".peridot-score").forEach((div) => {
        div.textContent = "";
    });
    document
        .querySelectorAll(
            "#diamond-score-readout, #silver-score-readout, #lapis-score-readout, #peridot-score-readout, #topaz-score-readout, #opal-score-readout, #amber-score-readout, #q-s-c-score-readout"
        )
        .forEach((readout) => {
            readout.textContent = "";
        });
    const finalScoreDiv = document.getElementById("final-score");
    if (finalScoreDiv) finalScoreDiv.textContent = "";
    document
        .querySelectorAll(
            ".quartz-bonus-circle, .sandstone-bonus-circle, .coal-bonus-circle"
        )
        .forEach((bonus) => {
            bonus.classList.remove("circled", "disabled");
            bonus.style.opacity = "1";
            const circle = bonus.querySelector("circle");
            if (circle) {
                circle.setAttribute("stroke", "black");
                circle.setAttribute("stroke-dashoffset", "110");
            }
        });
    document
        .querySelectorAll(".oil-square, .oil-square-final")
        .forEach((square) => {
            square.style.display = "none";
            square.classList.remove("pulsing-oil-square");
        });
    ngCrossoffDivs.forEach((div) => {
        div.classList.remove("crossed-off", "clickable", "used");
        div.style.backgroundColor = ""; // Clear inline style to default to CSS transparent
        div.style.pointerEvents = "none";
        div.style.opacity = "0.5";
    });
    ngBonusDivs.forEach((bonusDiv) => {
        bonusDiv.style.display = "none";
        bonusDiv.classList.remove("pulsing-ng-bonus");
    });
    diamondCount = 0;
    silverCount = 0;
    quartzCount = 0;
    sandstoneCount = 0;
    coalCount = 0;
    lapisCount = 0;
    peridotCount = 0;
    topazCount = 0;
    opalCount = 0;
    amberCount = 0;
    oilCount = 0;
    ngCount = 0;
    rowBonusCount = 0;
    columnBonusCount = 0;
    boulderBonusCount = 0;
    rollCount = 0;
    isFirstRoll = true;
    quartzBonus = false;
    sandstoneBonus = false;
    coalBonus = false;
    peridotScores = [0, 0, 0, 0, 0];
    oilBonusQueue = []; // Clear oil bonus queue
    bonusDigMode = false; // Explicitly reset bonus dig mode
    const digButton = document.getElementById("dig-button");
    if (digButton) {
        digButton.classList.remove("bonus-mode", "pulsing-dig");
        digButton.classList.add("loading");
        digButton.style.opacity = "0.5";
        digButton.style.pointerEvents = "none";
        digButton.style.animation = "none"; // Prevent spin animation on new game
        const img = digButton.querySelector("img");
        if (img) img.src = "https://i.imgur.com/7tDYHqX.png"; // Restore default dig button image
    }
    const rollButton = document.getElementById("roll-button");
    if (rollButton) {
        rollButton.classList.remove("loading");
        rollButton.classList.add("loaded", "pulsing-roll");
        rollButton.style.opacity = "1";
        rollButton.style.pointerEvents = "auto";
    }
    const greenImage = document.getElementById("green-image");
    const whiteImage = document.getElementById("white-image");
    if (greenImage) {
        greenImage.classList.remove("show");
        greenImage.classList.add("hide");
        greenImage.style.bottom = "";
        greenImage.innerHTML = `<img src="${imageMap[currentRollSheet].green[6]}" alt="Die Image">`;
        console.log("Reset #green-image to off-screen with .hide");
    }
    if (whiteImage) {
        whiteImage.classList.remove("show");
        whiteImage.classList.add("hide");
        whiteImage.style.bottom = "";
        whiteImage.innerHTML = `<img src="${imageMap[currentRollSheet].white[6]}" alt="Die Image">`;
        console.log("Reset #white-image to off-screen with .hide");
    }
    // NEW: Reset finish/screenshot elements to initial states
    const finishButton = document.getElementById("finish-button");
    const screenshotButton = document.getElementById("screenshot-button");
    const finalScoreBubble = document.getElementById("final-score-bubble");
    const screenshotExplainer = document.getElementById("screenshot-explainer");
    const endGameOverlay = document.getElementById("end-game-overlay");
    if (finishButton) {
        finishButton.style = ""; // Clear all inline styles
        finishButton.classList.remove("off-screen"); // Ensure no hidden class
        finishButton.style.bottom = "10cqh";
        finishButton.style.opacity = "1";
        finishButton.style.pointerEvents = "auto";
    }
    if (screenshotButton) {
        screenshotButton.style = ""; // Clear all inline styles
        screenshotButton.classList.add("off-screen"); // Re-apply initial hidden class
        screenshotButton.style.bottom = "-10cqh";
        screenshotButton.style.opacity = "0";
        screenshotButton.style.left = "50%";
        screenshotButton.style.transform = "translateX(-50%) scale(1.0)";
        screenshotButton.offsetHeight; // Force reflow
    }
    if (finalScoreBubble) {
        finalScoreBubble.style = ""; // Clear all inline styles
        finalScoreBubble.classList.add("hidden-state"); // Re-apply initial hidden class
        finalScoreBubble.style.bottom = "-10cqh";
        finalScoreBubble.style.left = "50%";
        finalScoreBubble.style.opacity = "0";
        finalScoreBubble.style.pointerEvents = "none";
        finalScoreBubble.style.transform = "translateX(-50%) scale(1.0)";
        finalScoreBubble.textContent = "";
        finalScoreBubble.offsetHeight; // Force reflow
    }
    if (screenshotExplainer) {
        screenshotExplainer.style = ""; // Clear all inline styles
        screenshotExplainer.classList.add("hidden-state"); // Re-apply initial hidden class
        screenshotExplainer.style.opacity = "0";
        screenshotExplainer.offsetHeight; // Force reflow
    }
    if (endGameOverlay) {
        endGameOverlay.classList.add("hidden");
    }
    updateNgCrossoffState();
    updateQuartzClickers();
    updateSandstoneClickers();
    updateCoalClickers();
    updateDiamondClickers();
    updateSilverClickers();
    updateLapisClickers();
    updatePeridotClickers();
    updateTopazClickers();
    updateOpalClickers();
    updateAmberClickers();
    updateOilClickers();
    updateNgClickers();
    updateOilNgCrossOffClickers();
    updateCellCursors();
    gamePhase = "roll";
    updateRollButtonState();
    updateDigButtonState();
    updateCellCursors();
    console.log(
        "Score sheet reset: All circle clickers cleared, stroke-dashoffset reset"
    );
    console.log(
        "Diamond clickers circled:",
        document.querySelectorAll(".diamond-circle-clicker.circled").length
    );
    console.log(
        "Quartz clickers circled:",
        document.querySelectorAll(".quartz-circle-clicker.circled").length
    );
    console.log(
        "Oil clickers circled:",
        document.querySelectorAll(".oil-circle-clicker.circled").length
    );
    console.log(
        "NG clickers circled:",
        document.querySelectorAll(".ng-circle-clicker.circled").length
    );
    console.log("Bonus dig mode reset:", bonusDigMode);
    if (tutorialMode) {
        tutorialStep = 0;
        advanceTutorialStep(); // Start tutorial on new game
    }
}
function dfs(index, group, visited, cellSet = selectedCells) {
	if (visited.has(index) || !cellSet.has(index)) return;
	visited.add(index);
	group.add(index);
	const row = Math.floor(index / 10);
	const col = index % 10;
	const directions = [
		[-1, 0],
		[1, 0],
		[0, -1],
		[0, 1]
	];
	for (let [dx, dy] of directions) {
		const newRow = row + dx;
		const newCol = col + dy;
		if (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10) {
			const neighborIndex = newRow * 10 + newCol;
			dfs(neighborIndex, group, visited, cellSet);
		}
	}
}
function generatePolyominoPath(group) {
	if (group.size === 0) return "";
	const cellSize = 100 / 10;
	const cells = Array.from(group).map((index) => ({
		row: Math.floor(index / 10),
		col: index % 10
	}));
	const edges = [];
	for (const { row, col } of cells) {
		const directions = [
			{ dr: -1, dc: 0, edge: "top", start: [col, row], end: [col + 1, row] },
			{
				dr: 1,
				dc: 0,
				edge: "bottom",
				start: [col, row + 1],
				end: [col + 1, row + 1]
			},
			{ dr: 0, dc: -1, edge: "left", start: [col, row], end: [col, row + 1] },
			{
				dr: 0,
				dc: 1,
				edge: "right",
				start: [col + 1, row],
				end: [col + 1, row + 1]
			}
		];
		for (const { dr, dc, edge, start, end } of directions) {
			const newRow = row + dr;
			const newCol = col + dc;
			const neighborIndex = newRow * 10 + newCol;
			if (
				newRow < 0 ||
				newRow >= 10 ||
				newCol < 0 ||
				newCol >= 10 ||
				!group.has(neighborIndex)
			) {
				edges.push({ edge, start, end });
			}
		}
	}
	const sortedEdges = [];
	const used = new Set();
	let current = edges[0];
	if (!current) return "";
	sortedEdges.push(current);
	used.add(0);
	while (used.size < edges.length) {
		let found = false;
		for (let i = 0; i < edges.length; i++) {
			if (!used.has(i)) {
				const edge = edges[i];
				if (
					Math.abs(edge.start[0] - current.end[0]) < 0.01 &&
					Math.abs(edge.start[1] - current.end[1]) < 0.01
				) {
					sortedEdges.push(edge);
					used.add(i);
					current = edge;
					found = true;
					break;
				} else if (
					Math.abs(edge.end[0] - current.end[0]) < 0.01 &&
					Math.abs(edge.end[1] - current.end[1]) < 0.01
				) {
					sortedEdges.push({ edge: edge.edge, start: edge.end, end: edge.start });
					used.add(i);
					current = { edge: edge.edge, start: edge.end, end: edge.start };
					found = true;
					break;
				}
			}
		}
		if (!found) {
			for (let i = 0; i < edges.length; i++) {
				if (!used.has(i)) {
					current = edges[i];
					sortedEdges.push(current);
					used.add(i);
					break;
				}
			}
		}
	}
	if (sortedEdges.length === 0) return "";
	let path = `M ${sortedEdges[0].start[0] * cellSize} ${
		sortedEdges[0].start[1] * cellSize
	}`;
	for (const edge of sortedEdges) {
		path += ` L ${edge.end[0] * cellSize} ${edge.end[1] * cellSize}`;
	}
	if (
		Math.abs(
			sortedEdges[sortedEdges.length - 1].end[0] - sortedEdges[0].start[0]
		) < 0.01 &&
		Math.abs(
			sortedEdges[sortedEdges.length - 1].end[1] - sortedEdges[0].start[1]
		) < 0.01
	) {
		path += " Z";
	}
	return path;
}

function updateRollButtonState() {
	const rollButton = document.getElementById("roll-button");
	const enabled = gamePhase === "roll" && rollCount < 9;
	rollButton.classList.toggle("loaded", enabled);
	rollButton.classList.toggle("loading", !enabled);
	rollButton.classList.toggle("pulsing-roll", enabled);
	rollButton.style.opacity = enabled ? "1" : "0.5";
	rollButton.style.pointerEvents = enabled ? "auto" : "none";
}

function updatePolyominoOutline() {
    outlines.forEach((outline) => outline.remove());
    outlines.clear();
    const grid = document.getElementById("grid");
    // Draw for lockedGroups first (white)
    lockedGroups.forEach((lockedGroup, lgIndex) => {
        const pathData = generatePolyominoPath(lockedGroup);
        if (pathData) {
            const svg = createPolyominoSvg(pathData, "white");
            svg.classList.add("locked-svg");
            grid.appendChild(svg);
            outlines.set(-lgIndex - 1, svg); // Negative key to distinguish
        }
    });
    // Draw for selectedCells last (black) to ensure it appears on top
    const selectedVisited = new Set();
    for (let startIndex of Array.from(selectedCells)) {
        if (!selectedVisited.has(startIndex)) {
            const group = new Set();
            dfs(startIndex, group, selectedVisited, selectedCells);
            if (group.size > 0) {
                const pathData = generatePolyominoPath(group);
                if (pathData) {
                    const svg = createPolyominoSvg(pathData, "#000000");
                    svg.classList.add("selection-svg");
                    grid.appendChild(svg);
                    outlines.set(startIndex, svg);
                }
            }
        }
    }
    updateCellCursors();
    updateDigButtonState();
    if (tutorialMode && (tutorialStep === 4 || tutorialStep === 7) && selectedCells.size === 6) {
        // Check if all selected match allowed (sorted comparison)
        const selectedArray = Array.from(selectedCells).sort((a, b) => a - b);
        const allowedArray = tutorialAllowedCells.sort((a, b) => a - b);
        if (JSON.stringify(selectedArray) === JSON.stringify(allowedArray)) {
            const digButton = document.getElementById("dig-button");
            if (digButton) {
                digButton.style.pointerEvents = "auto";
                digButton.style.opacity = "1";
                console.log("All 6 cells selected, enabled dig button at step", tutorialStep);
            }
            if (tutorialStep === 4) advanceTutorialStep(); // For first: advance to show message4
        }
    } else if (tutorialMode && tutorialStep === 10 && selectedCells.size === 2) {
        const selectedArray = Array.from(selectedCells).sort((a, b) => a - b);
        const allowedArray = tutorialAllowedCells.sort((a, b) => a - b);
        if (JSON.stringify(selectedArray) === JSON.stringify(allowedArray)) {
            advanceTutorialStep(); // Show message10 ("Great, now... lock it")
        }
    } else if (tutorialMode && tutorialStep === 12 && selectedCells.size === 3) {
        const selectedArray = Array.from(selectedCells).sort((a, b) => a - b);
        const allowedArray = tutorialAllowedCells.sort((a, b) => a - b);
        if (JSON.stringify(selectedArray) === JSON.stringify(allowedArray)) {
            const digButton = document.getElementById("dig-button");
            if (digButton) {
                digButton.style.pointerEvents = "auto";
                digButton.style.opacity = "1";
                console.log("All 3 cells selected, enabled dig button at step 12");
            }
        }
    } else if (tutorialMode && tutorialStep === 14 && selectedCells.size === 5) {
        const selectedArray = Array.from(selectedCells).sort((a, b) => a - b);
        const allowedArray = tutorialAllowedCells.sort((a, b) => a - b);
        if (JSON.stringify(selectedArray) === JSON.stringify(allowedArray)) {
            const digButton = document.getElementById("dig-button");
            if (digButton) {
                digButton.style.pointerEvents = "auto";
                digButton.style.opacity = "1";
                console.log("All 5 cells selected, enabled dig button at step 14");
            }
        }
    } else if (tutorialMode && tutorialStep === 15 && selectedCells.size === 1) {
        const selectedArray = Array.from(selectedCells).sort((a, b) => a - b);
        const allowedArray = tutorialAllowedCells.sort((a, b) => a - b);
        if (JSON.stringify(selectedArray) === JSON.stringify(allowedArray)) {
            const digButton = document.getElementById("dig-button");
            if (digButton) {
                digButton.style.pointerEvents = "auto";
                digButton.style.opacity = "1";
                console.log("Bonus cell selected, enabled dig button at step 15");
            }
        }
    } else if (tutorialMode && tutorialStep === 18 && selectedCells.size === 5) {
        const selectedArray = Array.from(selectedCells).sort((a, b) => a - b);
        const allowedArray = tutorialAllowedCells.sort((a, b) => a - b);
        if (JSON.stringify(selectedArray) === JSON.stringify(allowedArray)) {
            const digButton = document.getElementById("dig-button");
            if (digButton) {
                digButton.style.pointerEvents = "auto";
                digButton.style.opacity = "1";
                console.log("All 5 cells selected for final guided dig, enabled dig button at step 18");
            }
        }
    }
}

function createPolyominoSvg(pathData, strokeColor) {
	const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
	svg.classList.add("polyomino-svg");
	svg.setAttribute("viewBox", "0 0 100 100");
	svg.setAttribute("width", "100%");
	svg.setAttribute("height", "100%");
	svg.setAttribute("preserveAspectRatio", "xMidYMid meet");
	svg.style.position = "absolute";
	svg.style.top = "0";
	svg.style.left = "0";
	svg.style.zIndex = "10";
	svg.style.transform = "translateZ(0)";
	const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
	path.setAttribute("d", pathData);
	path.setAttribute("stroke", strokeColor);
	path.setAttribute("stroke-width", "0.5");
	path.setAttribute("stroke-linecap", "round");
	path.setAttribute("fill", "none");
	path.setAttribute("vector-effect", "non-scaling-stroke");
	if (strokeColor === "white") {
		path.classList.add("locked-path"); // Add class for CSS specificity
	}
	svg.appendChild(path);
	requestAnimationFrame(() => {
		svg.style.display = "none";
		svg.offsetHeight;
		svg.style.display = "block";
	});
	return svg;
}
function saveState() {
	const grid = document.getElementById("grid");
	const committedSvgs = Array.from(
		grid.querySelectorAll(".polyomino-svg.committed-svg")
	);
	const committedCellsClone = new Map(committedCells);
	const committedCellIndices = new Set(committedCells.keys());
	return {
		committedCells: committedCellsClone,
		svgs: committedSvgs,
		committedCellIndices: committedCellIndices,
		oilCount: oilCount,
		ngCount: ngCount,
		quartzCount: quartzCount,
		sandstoneCount: sandstoneCount,
		coalCount: coalCount,
		silverCount: silverCount,
		diamondCount: diamondCount,
		lapisCount: lapisCount,
		peridotCount: peridotCount,
		topazCount: topazCount,
		opalCount: opalCount,
		amberCount: amberCount,
		circleClickers: Array.from(document.querySelectorAll(".circle-clicker")).map(
			(clicker) => ({
				class: clicker.className,
				circled: clicker.classList.contains("circled")
			})
		),
		crossOffs: {
			rows: Array.from(document.querySelectorAll(".row-cross-off")).map((c) =>
				c.classList.contains("crossed-off")
			),
			columns: Array.from(
				document.querySelectorAll(".column-cross-off")
			).map((c) => c.classList.contains("crossed-off")),
			boulders: Array.from(
				document.querySelectorAll(".boulder-cross-off")
			).map((c) => c.classList.contains("crossed-off")),
			oilNg: Array.from(
				document.querySelectorAll(".oil-ng-cross-off-clicker")
			).map((c) => c.classList.contains("crossed-off")),
			rounds: Array.from(document.querySelectorAll(".cross-off-round")).map((c) =>
				c.classList.contains("crossed-off")
			),
			ngCrossoffs: Array.from(document.querySelectorAll(".ng-cross-off")).map(
				(c) => ({
					crossedOff: c.classList.contains("crossed-off"),
					used: c.classList.contains("used")
				})
			)
		}
	};
}
function commitPolyomino() {
    console.log("Dig button clicked");
    const allNewSize =
        selectedCells.size + lockedGroups.reduce((acc, g) => acc + g.size, 0);
    if (allNewSize === 0 || !isConnectedGraph()) return;
    if (!bonusDigMode) {
        stateHistory = [];
        stateHistory.push(saveState());
    }
    // Force to dig view at start to ensure consistent starting point, without transition
    const container = document.getElementById("game-container");
    container.style.transition = "none"; // Disable transition for instant jump
    const shift = getShiftAmount();
    container.style.transform = `translateX(-${1 * shift}vw)`;
    currentView = 1;
    updateButtons();
    container.offsetHeight; // Reflow
    container.style.transition = "transform 0.5s ease"; // Re-enable transition
    const visited = new Set();
    const grid = document.getElementById("grid");
    const currentCommit = new Set();
    const currentSvgs = [];
    const isNarrowScreen = !window.matchMedia("(min-aspect-ratio: 4/3)").matches;
    grid
        .querySelectorAll(".selection-svg, .locked-svg")
        .forEach((svg) => svg.remove());
    // Collect all new groups: selected's disconnected + locked
    const newGroups = [];
    const selectedVisited = new Set();
    for (let start of Array.from(selectedCells)) {
        if (!selectedVisited.has(start)) {
            const group = new Set();
            dfs(start, group, selectedVisited, selectedCells);
            if (group.size > 0) {
                newGroups.push(group);
            }
        }
    }
    lockedGroups.forEach((g) => newGroups.push(new Set(g)));
    // Draw committed SVG per new group (black)
    for (let grp of newGroups) {
        const pathData = generatePolyominoPath(grp);
        if (pathData) {
            const svg = createPolyominoSvg(pathData, "#000000");
            svg.classList.add("committed-svg");
            svg.classList.add("flash");
            grid.appendChild(svg);
            setTimeout(() => svg.classList.remove("flash"), 200);
            grp.forEach((index) => {
                const cell = document.querySelector(`.cell[data-index="${index}"]`);
                cell.classList.add("committed");
                committedCells.set(index, svg);
                currentCommit.add(index);
            });
            currentSvgs.push(svg);
        }
    }
    playSound("pickaxe");
    const cellsArray = Array.from(
        new Set(newGroups.flatMap((g) => Array.from(g)))
    );
    const elementOrder = [
        "oil",
        "ng",
        "quartz",
        "sandstone",
        "coal",
        "silver",
        "diamond",
        "lapis",
        "peridot",
        "topaz",
        "opal",
        "amber"
    ];
    const boulderCenters = {
        "dig-sheet-a": [
            { row: 2, col: 6, index: 1 },
            { row: 3, col: 3, index: 2 },
            { row: 4, col: 7, index: 3 },
            { row: 8, col: 7, index: 4 },
            { row: 9, col: 5, index: 5 }
        ],
        "dig-sheet-b": [
            { row: 2, col: 7, index: 1 },
            { row: 3, col: 3, index: 2 },
            { row: 5, col: 5, index: 3 },
            { row: 8, col: 2, index: 4 },
            { row: 8, col: 6, index: 5 }
        ],
        "dig-sheet-c": [
            { row: 2, col: 6, index: 1 },
            { row: 3, col: 3, index: 2 },
            { row: 5, col: 6, index: 3 },
            { row: 6, col: 8, index: 4 },
            { row: 9, col: 5, index: 5 }
        ],
        "dig-sheet-d": [
            { row: 2, col: 6, index: 1 },
            { row: 3, col: 3, index: 2 },
            { row: 7, col: 4, index: 3 },
            { row: 7, col: 7, index: 4 },
            { row: 9, col: 6, index: 5 }
        ],
        "dig-sheet-e": [
            { row: 2, col: 7, index: 1 },
            { row: 3, col: 5, index: 2 },
            { row: 7, col: 2, index: 3 },
            { row: 9, col: 3, index: 4 },
            { row: 9, col: 8, index: 5 }
        ],
        "dig-sheet-f": [
            { row: 2, col: 3, index: 1 },
            { row: 3, col: 9, index: 2 },
            { row: 5, col: 8, index: 3 },
            { row: 6, col: 3, index: 4 },
            { row: 9, col: 5, index: 5 }
        ],
        "dig-sheet-g": [
            { row: 3, col: 5, index: 1 },
            { row: 3, col: 7, index: 2 },
            { row: 5, col: 3, index: 3 },
            { row: 7, col: 9, index: 4 },
            { row: 8, col: 2, index: 5 }
        ],
        "dig-sheet-h": [
            { row: 2, col: 5, index: 1 },
            { row: 4, col: 6, index: 2 },
            { row: 5, col: 4, index: 3 },
            { row: 8, col: 4, index: 4 },
            { row: 8, col: 7, index: 5 }
        ]
    }[currentDigSheet];
    let animationQueue = [];
    let gridElements = [];
    let bonusElements = [];
    let rowBonuses = [];
    const unclickableCells = digSheetConfigs[currentDigSheet].unclickableCells;
    for (let row = 0; row < 10; row++) {
        const rowCells = Array.from({ length: 10 }, (_, col) => row * 10 + col);
        const clickableRowCells = rowCells.filter(
            (index) => !unclickableCells.has(index)
        );
        const committedInRow = clickableRowCells.filter((index) =>
            committedCells.has(index)
        );
        if (
            committedInRow.length >= clickableRowCells.length &&
            clickableRowCells.length > 0
        ) {
            const rowIndex = row + 1;
            const rowClicker = Array.from(
                document.querySelectorAll(".row-cross-off")
            ).find(
                (clicker) =>
                    rowPositionToIndex[clicker.style.cssText] === rowIndex ||
                    parseInt(clicker.dataset.index) + 1 === rowIndex
            );
            if (rowClicker && !rowClicker.classList.contains("crossed-off")) {
                rowBonuses.push({ type: "cell-flash", indices: clickableRowCells });
                rowBonuses.push({ type: "row", index: rowIndex });
                if (coordinates[currentDigSheet]) {
                    for (const [gem, config] of Object.entries(coordinates[currentDigSheet])) {
                        const rowConfigs = config.row?.filter((r) => r.index === rowIndex) || [];
                        rowConfigs.forEach((rowConfig) => {
                            for (let i = 0; i < rowConfig.count; i++) {
                                bonusElements.push({ type: "element", gem });
                            }
                        });
                    }
                }
                console.log(`Row ${rowIndex} completed, will flash cells and cross off`);
            }
        }
    }
    let columnBonuses = [];
    for (let col = 0; col < 10; col++) {
        const colCells = Array.from({ length: 10 }, (_, row) => row * 10 + col);
        const clickableColCells = colCells.filter(
            (index) => !unclickableCells.has(index)
        );
        const committedInCol = clickableColCells.filter((index) =>
            committedCells.has(index)
        );
        if (
            committedInCol.length >= clickableColCells.length &&
            clickableColCells.length > 0
        ) {
            const colIndex = col + 1;
            const colClicker = Array.from(
                document.querySelectorAll(".column-cross-off")
            ).find(
                (clicker) =>
                    columnPositionToIndex[clicker.style.cssText] === colIndex ||
                    parseInt(clicker.dataset.index) + 1 === colIndex
            );
            if (colClicker && !colClicker.classList.contains("crossed-off")) {
                columnBonuses.push({ type: "cell-flash", indices: clickableColCells });
                columnBonuses.push({ type: "column", index: colIndex });
                if (coordinates[currentDigSheet]) {
                    for (const [gem, config] of Object.entries(coordinates[currentDigSheet])) {
                        const colConfigs =
                            config.column?.filter((c) => c.index === colIndex) || [];
                        colConfigs.forEach((colConfig) => {
                            for (let i = 0; i < colConfig.count; i++) {
                                bonusElements.push({ type: "element", gem });
                            }
                        });
                    }
                }
                console.log(`Column ${colIndex} completed, will flash cells and cross off`);
            }
        }
    }
    let boulderBonuses = [];
    for (const { row, col, index } of boulderCenters) {
        const neighbors = [
            { r: row - 1, c: col - 1 },
            { r: row - 1, c: col },
            { r: row - 1, c: col + 1 },
            { r: row, c: col - 1 },
            { r: row, c: col + 1 },
            { r: row + 1, c: col - 1 },
            { r: row + 1, c: col },
            { r: row + 1, c: col + 1 }
        ].filter(({ r, c }) => r >= 1 && r <= 10 && c >= 1 && c <= 10);
        const neighborIndices = neighbors.map(({ r, c }) => (r - 1) * 10 + (c - 1));
        if (neighborIndices.every((idx) => committedCells.has(idx))) {
            const boulderClicker = Array.from(
                document.querySelectorAll(".boulder-cross-off")
            ).find((clicker) => parseInt(clicker.dataset.index) + 1 === index);
            if (boulderClicker && !boulderClicker.classList.contains("crossed-off")) {
                boulderBonuses.push({ type: "cell-flash", indices: neighborIndices });
                boulderBonuses.push({ type: "boulder", index });
                if (coordinates[currentDigSheet]) {
                    for (const [gem, config] of Object.entries(coordinates[currentDigSheet])) {
                        const boulderConfigs =
                            config.boulder?.filter((b) => b.index === index) || [];
                        boulderConfigs.forEach((boulderConfig) => {
                            for (let i = 0; i < boulderConfig.count; i++) {
                                bonusElements.push({ type: "element", gem });
                            }
                        });
                    }
                }
                console.log(`Boulder ${index} completed, will flash cells and cross off`);
            }
        }
    }
    let allElements = [];
    let digSheetElements = [];
    let scoreSheetElements = [];
    let newOilCount = 0;
    if (coordinates[currentDigSheet]) {
        const gridCells = coordinates[currentDigSheet];
        cellsArray.forEach((index) => {
            const row = Math.floor(index / 10) + 1;
            const col = (index % 10) + 1;
            for (const [gem, config] of Object.entries(gridCells)) {
                if (config.grid?.some((cell) => cell.row === row && cell.col === col)) {
                    allElements.push({ type: "element", gem });
                    if (gem === "oil") newOilCount++;
                    console.log(`Found ${gem} at grid cell (${row}, ${col})`);
                }
            }
        });
    }
    allElements.push(...bonusElements);
    bonusElements.forEach(({ gem }) => {
        if (gem === "oil") newOilCount++;
    });
    allElements.sort(
        (a, b) => elementOrder.indexOf(a.gem) - elementOrder.indexOf(b.gem)
    );
    allElements.forEach((element) => {
        if (element.gem === "oil" || element.gem === "ng") {
            digSheetElements.push(element);
        } else {
            scoreSheetElements.push(element);
        }
    });
    // Predict oil bonuses
    const prevOilCount = oilCount;
    const tempOilCount = oilCount + newOilCount;
    const newBonuses = [];
    if (tempOilCount >= 2 && prevOilCount < 2) newBonuses.push(0); // 2nd oil -> clicker 0
    if (tempOilCount >= 4 && prevOilCount < 4) newBonuses.push(1); // 4th oil -> clicker 1
    if (tempOilCount >= 5 && prevOilCount < 5) newBonuses.push(2); // 5th oil -> clicker 2
    if (tempOilCount >= 6 && prevOilCount < 6) newBonuses.push(3); // 6th oil -> clicker 3
    if (tempOilCount >= 7 && prevOilCount < 7) {
        newBonuses.push(4, 4); // 7th oil -> clicker 4 (twice)
    }
    oilBonusQueue.push(...newBonuses); // Always append to end for FIFO order
    console.log(
        `Oil bonuses queued: ${newBonuses}, total queue: ${oilBonusQueue}, bonusDigMode: ${bonusDigMode}`
    );
    selectedCells.clear();
    lockedGroups = [];
    outlines.clear();
    updatePolyominoOutline();
    updateCellCursors();
    updateDigButtonState();
    if (tutorialMode) {
        // Clear highlights/restrictions after dig
        document.querySelectorAll(".tutorial-highlight").forEach(cell => cell.classList.remove("tutorial-highlight"));
        document.querySelectorAll(".cell.no-pointer:not(.disabled)").forEach(cell => cell.classList.remove("no-pointer"));
        tutorialAllowedCells = [];
    }
    let delay = 500;
    animationQueue.push(...rowBonuses);
    animationQueue.push(...columnBonuses);
    animationQueue.push(...boulderBonuses);
    let didScrollToScore = false; // Track if we scrolled to score
    if (digSheetElements.length > 0 || scoreSheetElements.length > 0) {
        animationQueue.push(...digSheetElements);
        if (scoreSheetElements.length > 0 && isNarrowScreen) {
            animationQueue.push({ type: "scroll", action: "score" });
            didScrollToScore = true;
        }
        animationQueue.push(...scoreSheetElements);
        if (isNarrowScreen && didScrollToScore) {
            animationQueue.push({ type: "scroll", action: "dig" });
        }
    }
    // Hide current oil square before processing next bonus
    const oilSquareMap = {
        0: "oil-square-1",
        1: "oil-square-2",
        2: "oil-square-3",
        3: "oil-square-4",
        4: "oil-square-5"
    };
    if (bonusDigMode) {
        const currentOilSquareId = oilSquareMap[oilBonusQueue[0]];
        if (currentOilSquareId) {
            const currentOilSquare = document.getElementById(currentOilSquareId);
            if (currentOilSquare) {
                currentOilSquare.style.display = "none";
                currentOilSquare.classList.remove("pulsing-oil-square");
            }
        }
    }
    animationQueue.forEach((item, index) => {
        setTimeout(() => {
            if (item.type === "element") {
                const gem = item.gem;
                switch (gem) {
                    case "quartz":
                        quartzCount = Math.max(0, quartzCount + 1);
                        updateQuartzClickers();
                        break;
                    case "sandstone":
                        sandstoneCount = Math.max(0, sandstoneCount + 1);
                        updateSandstoneClickers();
                        break;
                    case "coal":
                        coalCount = Math.max(0, coalCount + 1);
                        updateCoalClickers();
                        break;
                    case "silver":
                        silverCount = Math.max(0, silverCount + 1);
                        updateSilverClickers();
                        break;
                    case "diamond":
                        diamondCount = Math.max(0, diamondCount + 1);
                        updateDiamondClickers();
                        break;
                    case "lapis":
                        lapisCount = Math.max(0, lapisCount + 1);
                        updateLapisClickers();
                        break;
                    case "peridot":
                        peridotCount = Math.max(0, peridotCount + 1);
                        const greenDieValue =
                            parseInt(document.getElementById("die1").getAttribute("data-value")) ||
                            0;
                        if (greenDieValue > 0) {
                            const scoreDiv = document.querySelectorAll(".peridot-score")[
                                peridotCount - 1
                            ];
                            if (scoreDiv) scoreDiv.textContent = greenDieValue;
                        }
                        updatePeridotClickers();
                        break;
                    case "topaz":
                        topazCount = Math.max(0, topazCount + 1);
                        updateTopazClickers();
                        break;
                    case "opal":
                        opalCount = Math.max(0, opalCount + 1);
                        updateOpalClickers();
                        break;
                    case "amber":
                        amberCount = Math.max(0, amberCount + 1);
                        updateAmberClickers();
                        break;
                    case "oil":
                        oilCount = Math.max(0, oilCount + 1);
                        updateOilClickers();
                        break;
                    case "ng":
                        ngCount = Math.max(0, ngCount + 1);
                        updateNgClickers();
                        break;
                }
                console.log(
                    `Circled ${gem} (index ${index}), new ${gem}Count: ${
                        window[`${gem}Count`]
                    }`
                );
                playSound("circle");
            } else if (item.type === "row") {
                const rowIndex = item.index;
                const rowClicker = Array.from(
                    document.querySelectorAll(".row-cross-off")
                ).find(
                    (clicker) =>
                        rowPositionToIndex[clicker.style.cssText] === rowIndex ||
                        parseInt(clicker.dataset.index) + 1 === rowIndex
                );
                if (rowClicker && !rowClicker.classList.contains("crossed-off")) {
                    rowClicker.classList.add("crossed-off");
                    rowBonusCount++;
                    updateOpalClickers();
                    console.log(
                        `Crossed off row ${rowIndex} (index ${index}) at ${Date.now()}ms`
                    );
                    playSound("crossOff");
                }
            } else if (item.type === "column") {
                const colIndex = item.index;
                const colClicker = Array.from(
                    document.querySelectorAll(".column-cross-off")
                ).find(
                    (clicker) =>
                        columnPositionToIndex[clicker.style.cssText] === colIndex ||
                        parseInt(clicker.dataset.index) + 1 === colIndex
                );
                if (colClicker && !colClicker.classList.contains("crossed-off")) {
                    colClicker.classList.add("crossed-off");
                    columnBonusCount++;
                    updateOpalClickers();
                    console.log(
                        `Crossed off column ${colIndex} (index ${index}) at ${Date.now()}ms`
                    );
                    playSound("crossOff");
                }
            } else if (item.type === "boulder") {
                const boulderIndex = item.index;
                const boulderClicker = Array.from(
                    document.querySelectorAll(".boulder-cross-off")
                ).find((clicker) => parseInt(clicker.dataset.index) + 1 === boulderIndex);
                if (boulderClicker && !boulderClicker.classList.contains("crossed-off")) {
                    boulderClicker.classList.add("crossed-off");
                    boulderBonusCount++;
                    updateAmberClickers();
                    console.log(
                        `Crossed off boulder ${boulderIndex} (index ${index}) at ${Date.now()}ms`
                    );
                    playSound("crossOff");
                }
            } else if (item.type === "cell-flash") {
                item.indices.forEach((index) => {
                    const cell = document.querySelector(`.cell[data-index="${index}"]`);
                    if (cell) {
                        cell.classList.add("cell-flash");
                        setTimeout(() => {
                            cell.classList.remove("cell-flash");
                        }, 500);
                        }
                    });
                console.log(
                    `Flashed cells for bonus (index ${index}): ${item.indices
                        .map((idx) => `(${((idx / 10) | 0) + 1}, ${(idx % 10) + 1})`)
                        .join(", ")}`
                );
                playSound("bonus");
            } else if (item.type === "scroll") {
                if (item.action === "score") {
                    scrollRight(); // Use scrollRight() for consistency
                    console.log(
                        `Scrolled to score sheet (index ${index}) at ${Date.now()}ms`
                    );
                } else if (item.action === "dig") {
                    scrollLeft(); // Use scrollLeft() to go back
                    console.log(
                        `Scrolled back to dig sheet (index ${index}) at ${Date.now()}ms`
                    );
                    if (tutorialMode && tutorialStep === 5) {
                        showTutorialMessage(tutorialMessages[5]); // "Cool, you collected..."
                        tutorialStep = 6; // Update to after message5
                    } else if (tutorialMode && tutorialStep === 7) {
                        showTutorialMessage(tutorialMessages[7]); // "You just got a bonus..."
                        tutorialStep = 8; // Update to after message7
                    } else if (tutorialMode && tutorialStep === 12) {
                        showTutorialMessage(tutorialMessages[12]);
                        tutorialStep = 13;
                    } else if (tutorialMode && tutorialStep === 15) {
                        showTutorialMessage(tutorialMessages[15]); // "You dug out an entire row..."
                        tutorialStep = 16; // Update to after message15
                    } else if (tutorialMode && tutorialStep === 18) {
                        showTutorialMessage(tutorialMessages[18]); // "Awesome, you're raking..."
                        tutorialStep = 19; // Update to after message18 (19 1-based)
                    }
                }
            }
            updateFinalScore();
        }, delay);
        delay += 500;
    });
    // Handle bonus mode transition after animations (or immediately if none)
    setTimeout(
        () => {
            console.log(
                `Final transition: bonusDigMode=${bonusDigMode}, oilBonusQueue=${oilBonusQueue}`
            );
            if (bonusDigMode && oilBonusQueue.length > 0) {
                const clickerIndex = oilBonusQueue.shift();
                // Only cross off clicker if it's not the first of two index 4 bonuses (7th oil)
                if (clickerIndex >= 0 && clickerIndex < oilNgCrossOffClickers.length) {
                    const clicker = oilNgCrossOffClickers[clickerIndex];
                    if (clicker && !clicker.classList.contains("crossed-off")) {
                        // For index 4 (7th oil), only cross off if the next queue item is not also 4
                        if (clickerIndex !== 4 || oilBonusQueue[0] !== 4) {
                            clicker.classList.add("crossed-off");
                            playSound("crossOff");
                            console.log(`Crossed off oil clicker ${clickerIndex}`);
                        }
                    }
                }
                if (oilBonusQueue.length > 0) {
                    console.log("Remaining bonuses, entering bonus dig mode");
                    enterBonusDigMode();
                } else {
                    console.log("No remaining bonuses, exiting bonus dig mode");
                    exitBonusDigMode();
                    // Tutorial: For round 9 bonus digs, show message 20 after final bonus collection (no score scroll assumed for bonus)
                    if (tutorialMode && rollCount === 9) {
                        showTutorialMessage(tutorialMessages[19]); // "You did it! Click the finish button..."
                        tutorialStep = 20; // Update to after message19 (20 1-based)
                    }
                }
            } else if (oilBonusQueue.length > 0 && !bonusDigMode) {
                console.log("Queue has bonuses, entering bonus dig mode");
                enterBonusDigMode();
            } else {
                console.log("No bonuses, transitioning to roll/end phase");
                gamePhase = rollCount < 9 ? "roll" : "end";
                updateRollButtonState();
                updateDigButtonState();
                updateCellCursors();
                updateNgCrossoffState();
                // Tutorial: For non-bonus round 9, show message 20 here
                if (tutorialMode && rollCount === 9) {
                    showTutorialMessage(tutorialMessages[19]); // "You did it! Click the finish button..."
                    tutorialStep = 20; // Update to after message19 (20 1-based)
                }
            }
            // Consume used NG-Crossoffs (lock them without reducing ngCount or uncircling)
            ngCrossoffDivs.forEach((div) => {
                if (
                    div.classList.contains("crossed-off") &&
                    !div.classList.contains("used")
                ) {
                    div.classList.add("used");
                    console.log(
                        `Consumed NG-Crossoff at index ${ngCrossoffDivs.indexOf(div)}`
                    );
                }
            });
            updateNgCrossoffState();
            // Force reflow to ensure final scroll-back renders (mobile fix)
            const container = document.getElementById("game-container");
            if (container) {
                container.offsetHeight; // Trigger reflow
            }
            // Tutorial: Show message06 after collection sequence (step 4 after dig)
            if (tutorialMode && tutorialStep === 5 && !didScrollToScore) {
                showTutorialMessage(tutorialMessages[5]); // "Cool, you collected..."
                tutorialStep = 6; // Update to after message5
            } else if (tutorialMode && tutorialStep === 7 && !didScrollToScore) {
                showTutorialMessage(tutorialMessages[7]); // "You just got a bonus..."
                tutorialStep = 8; // Update to after message7
            } else if (tutorialMode && tutorialStep === 12 && !didScrollToScore) {
                showTutorialMessage(tutorialMessages[12]);
                tutorialStep = 13;
            } else if (tutorialMode && tutorialStep === 15 && !didScrollToScore) {
                showTutorialMessage(tutorialMessages[15]); // "You dug out an entire row..."
                tutorialStep = 16; // Update to after message15
            } else if (tutorialMode && tutorialStep === 18 && !didScrollToScore) {
                showTutorialMessage(tutorialMessages[18]); // "Awesome, you're raking..."
                tutorialStep = 19; // Update to after message18 (19 1-based)
            }
        },
        animationQueue.length > 0 ? delay : 0
    );
}
function undoLastCommit() {
    if (stateHistory.length === 0) {
        if (selectedCells.size > 0 || lockedGroups.length > 0) {
            selectedCells.clear();
            lockedGroups = [];
            updatePolyominoOutline();
            updateDigButtonState();
            updateNgCrossoffState(); // Re-evaluate NG state after clearing selections
            playSound("click");
        }
        console.log("No state to undo, cleared selections if any");
        return;
    }
    const grid = document.getElementById("grid");
    const previousState = stateHistory.pop();
    console.log("Restoring state:", {
        committedCellIndices: Array.from(previousState.committedCellIndices),
        elementCounts: {
            oil: previousState.oilCount,
            ng: previousState.ngCount,
            quartz: previousState.quartzCount,
            sandstone: previousState.sandstoneCount,
            coal: previousState.coalCount,
            silver: previousState.silverCount,
            diamond: previousState.diamondCount,
            lapis: previousState.lapisCount,
            peridot: previousState.peridotCount,
            topaz: previousState.topazCount,
            opal: previousState.opalCount,
            amber: previousState.amberCount
        }
    });
    grid.querySelectorAll(".polyomino-svg").forEach((svg) => svg.remove());
    previousState.svgs.forEach((svg) => grid.appendChild(svg));
    committedCells = new Map(previousState.committedCells);
    document
        .querySelectorAll(".cell.committed")
        .forEach((cell) => cell.classList.remove("committed"));
    previousState.committedCellIndices.forEach((index) => {
        const cell = document.querySelector(`.cell[data-index="${index}"]`);
        if (cell) cell.classList.add("committed");
    });
    oilCount = previousState.oilCount;
    ngCount = previousState.ngCount;
    quartzCount = previousState.quartzCount;
    sandstoneCount = previousState.sandstoneCount;
    coalCount = previousState.coalCount;
    silverCount = previousState.silverCount;
    diamondCount = previousState.diamondCount;
    lapisCount = previousState.lapisCount;
    peridotCount = previousState.peridotCount;
    topazCount = previousState.topazCount;
    opalCount = previousState.opalCount;
    amberCount = previousState.amberCount;
    document.querySelectorAll(".circle-clicker").forEach((clicker) => {
        const stateClicker = previousState.circleClickers.find(
            (s) => s.class === clicker.className
        );
        if (stateClicker) {
            if (stateClicker.circled) {
                clicker.classList.add("circled");
            } else {
                clicker.classList.remove("circled");
            }
        }
    });
    // Restore cross-off states
    document.querySelectorAll(".row-cross-off").forEach((c, i) => {
        if (previousState.crossOffs.rows[i]) c.classList.add("crossed-off");
        else c.classList.remove("crossed-off");
    });
    document.querySelectorAll(".column-cross-off").forEach((c, i) => {
        if (previousState.crossOffs.columns[i]) c.classList.add("crossed-off");
        else c.classList.remove("crossed-off");
    });
    document.querySelectorAll(".boulder-cross-off").forEach((c, i) => {
        if (previousState.crossOffs.boulders[i]) c.classList.add("crossed-off");
        else c.classList.remove("crossed-off");
    });
    document.querySelectorAll(".oil-ng-cross-off-clicker").forEach((c, i) => {
        if (previousState.crossOffs.oilNg[i]) c.classList.add("crossed-off");
        else c.classList.remove("crossed-off");
    });
    document.querySelectorAll(".cross-off-round").forEach((c, i) => {
        if (previousState.crossOffs.rounds[i]) c.classList.add("crossed-off");
        else c.classList.remove("crossed-off");
    });
    document.querySelectorAll(".ng-cross-off").forEach((c, i) => {
        const state = previousState.crossOffs.ngCrossoffs[i];
        if (state) {
            c.classList.toggle("crossed-off", state.crossedOff);
            c.classList.toggle("used", state.used);
        }
    });
    // Recalculate bonus counts after restoring cross-offs
    rowBonusCount = document.querySelectorAll(".row-cross-off.crossed-off").length;
    columnBonusCount = document.querySelectorAll(".column-cross-off.crossed-off")
        .length;
    boulderBonusCount = document.querySelectorAll(".boulder-cross-off.crossed-off")
        .length;
    updateOilClickers();
    updateNgClickers();
    updateQuartzClickers();
    updateSandstoneClickers();
    updateCoalClickers();
    updateSilverClickers();
    updateDiamondClickers();
    updateLapisClickers();
    updatePeridotClickers();
    updateTopazClickers();
    updateOpalClickers();
    updateAmberClickers();
    updateOilNgCrossOffClickers();
    selectedCells.clear();
    lockedGroups = [];
    outlines.clear();
    updatePolyominoOutline();
    updateCellCursors();
    updateDigButtonState();
    updateNgCrossoffState();
    rollCount = document.querySelectorAll(".cross-off-round.crossed-off").length;
    gamePhase = "dig";
    updateRollButtonState();
    updateDigButtonState();
    updateCellCursors();
    // NEW: Clear bonus queue and exit mode (fixes stuck bonus after undo)
    oilBonusQueue = [];
    exitBonusDigMode(true);
    playSound("click");
}

function seededRandom(seed) {
	let hash = 0n; // Use BigInt for precision
	for (let i = 0; i < seed.length; i++) {
		hash = (hash * 31n + BigInt(seed.charCodeAt(i))) & 0x7fffffffn;
	}
	let x = hash;
	return function () {
		x = (x * 134775813n + 1n) & 0x7fffffffn;
		return Number(x) / 2147483647; // Convert back to Number for 0-1 range
	};
}

function switchDigSheet() {
	if (hasGameState()) {
		const confirmReset = window.confirm(
			"Are you sure you want to abandon the current game and switch dig sheets?"
		);
		if (!confirmReset) return;
	}
	const digSheetElement = document.getElementById("dig-sheet");
	const overlayImg = document.querySelector("#dig-sheet-overlay img");
	const currentIndex = digSheets.indexOf(currentDigSheet);
	const nextIndex = (currentIndex + 1) % digSheets.length;
	currentDigSheet = digSheets[nextIndex];
	if (!digSheetConfigs[currentDigSheet]) {
		console.error(
			`Invalid dig sheet ID: ${currentDigSheet}. Falling back to dig-sheet-a`
		);
		currentDigSheet = "dig-sheet-a";
	}
	digSheetElement.style.backgroundImage = `url(${digSheetBackgroundImages[currentDigSheet]})`;
	overlayImg.src = digSheetOverlayImages[currentDigSheet];
	digSheetElement.style.display = "none";
	digSheetElement.offsetHeight;
	digSheetElement.style.display = "block";
	const boulderElements = document.querySelectorAll(".boulder-cross-off");
	boulderElements.forEach((element, index) => {
		const config = digSheetBoulderConfigs[currentDigSheet][index];
		if (config) {
			element.style.top = config.top;
			element.style.left = config.left;
		}
	});
	// Update unclickable cells for the new dig sheet
	const grid = document.getElementById("grid");
	if (grid) {
		grid.querySelectorAll(".cell").forEach((cell) => {
			const index = parseInt(cell.dataset.index);
			if (digSheetConfigs[currentDigSheet].unclickableCells.has(index)) {
				cell.classList.add("disabled");
			} else {
				cell.classList.remove("disabled");
			}
		});
	} else {
		console.error("Grid element not found");
	}
	resetGrid();
	playSound("click");
	console.log(
		`Dig sheet switched to ${currentDigSheet}, unclickable cells:`,
		Array.from(digSheetConfigs[currentDigSheet].unclickableCells)
	);
}

function switchRollSheet() {
	if (hasGameState()) {
		const confirmReset = window.confirm(
			"Are you sure you want to abandon the current game and switch roll sheets?"
		);
		if (!confirmReset) return;
	}
	const rollSheetElement = document.getElementById("roll-sheet");
	const rollSheetImg = rollSheetElement.querySelector(
		"img:not(#green-image img):not(#white-image img)"
	);
	const currentIndex = rollSheets.indexOf(currentRollSheet);
	const nextIndex = (currentIndex + 1) % rollSheets.length;
	currentRollSheet = rollSheets[nextIndex];
	rollSheetImg.src = rollSheetImages[currentRollSheet];
	// Set default dice images (6 for both green and white)
	greenImage.innerHTML = `<img src="${imageMap[currentRollSheet].green[6]}" alt="Die Image">`;
	whiteImage.innerHTML = `<img src="${imageMap[currentRollSheet].white[6]}" alt="Die Image">`;
	die1.setAttribute("data-value", "6");
	die2.setAttribute("data-value", "6");
	// Force redraw
	rollSheetImg.style.display = "none";
	rollSheetImg.offsetHeight;
	rollSheetImg.style.display = "block";
	resetGrid();
	playSound("click");
	console.log(`Roll sheet switched to ${currentRollSheet}`);
}

function startDailyChallenge() {
	const now = new Date();
	const year = now.getFullYear();
	const month = (now.getMonth() + 1).toString().padStart(2, "0");
	const day = now.getDate().toString().padStart(2, "0");
	const dailySeed = `${year}-${month}-${day}`; // Local date for seed
	console.log("Daily Challenge Seed:", dailySeed);
	const random = seededRandom(dailySeed);
	const dailyDigIndex = Math.floor(random() * digSheets.length);
	currentDigSheet = digSheets[dailyDigIndex];
	console.log("Selected Dig Sheet:", currentDigSheet);
	const digSheetElement = document.getElementById("dig-sheet");
	const overlayImg = document.querySelector("#dig-sheet-overlay img");
	digSheetElement.style.backgroundImage = `url(${digSheetBackgroundImages[currentDigSheet]})`;
	overlayImg.src = digSheetOverlayImages[currentDigSheet];
	digSheetElement.style.display = "none";
	digSheetElement.offsetHeight;
	digSheetElement.style.display = "block";
	const dailyRollIndex = Math.floor(random() * rollSheets.length);
	currentRollSheet = rollSheets[dailyRollIndex];
	console.log("Selected Roll Sheet:", currentRollSheet);
	const rollSheetImg = document
		.getElementById("roll-sheet")
		.querySelector("img:not(#green-image img):not(#white-image img)");
	rollSheetImg.src = rollSheetImages[currentRollSheet];
	dailyDiceRolls.length = 0;
	for (let i = 0; i < 9; i++) {
		const greenRoll = Math.floor(random() * 6) + 1;
		const whiteRoll = Math.floor(random() * 6) + 1;
		dailyDiceRolls.push({ green: greenRoll, white: whiteRoll });
	}
	console.log("Daily Dice Rolls:", dailyDiceRolls);
	rollCount = 0;
	const boulderElements = document.querySelectorAll(".boulder-cross-off");
	boulderElements.forEach((element, index) => {
		const config = digSheetBoulderConfigs[currentDigSheet][index];
		if (config) {
			element.style.top = config.top;
			element.style.left = config.left;
		}
	});
	resetGrid();
	console.log("First random (dig): ", random());
	console.log("Second random (roll): ", random());
	console.log("First green roll: ", Math.floor(random() * 6) + 1);
}
function updateDailyChallengeTimer() {
	const now = new Date();
	const nextMidnight = new Date(now);
	nextMidnight.setHours(24, 0, 0, 0); // Midnight next day
	const timeDiff = nextMidnight - now;
	const hours = Math.floor(timeDiff / (1000 * 60 * 60));
	const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
	const seconds = Math.floor((timeDiff % (1000 * 60)) / 1000);
	const timerElement = document.getElementById("daily-challenge-timer");
	if (timerElement) {
		timerElement.textContent = `${hours
			.toString()
			.padStart(2, "0")}:${minutes
			.toString()
			.padStart(2, "0")}:${seconds.toString().padStart(2, "0")} remaining`;
	} else {
		console.error("Timer element not found");
	}
	setTimeout(updateDailyChallengeTimer, 1000);
}

function showTutorialMessage(text) {
    const overlay = document.getElementById("tutorial-overlay");
    const card = document.getElementById("tutorial-card");
    const cardText = document.getElementById("tutorial-text");
    if (overlay && card && cardText) {
        cardText.textContent = text;
        card.classList.remove("visible"); // Reset to initial state
        card.style.visibility = "hidden";
        overlay.classList.remove("visible"); // Reset overlay
        overlay.style.visibility = "hidden";
        card.offsetHeight; // Force reflow
        overlay.style.visibility = "visible"; // Show overlay
        overlay.classList.add("visible"); // Activate blocker
        card.style.visibility = "visible"; // Show card
        card.classList.add("visible"); // Trigger slide-up
        console.log(`Showing message: "${text}" at step ${tutorialStep}, bottom: ${card.style.bottom}, opacity: ${card.style.opacity}, visibility: ${card.style.visibility}`);
    } else {
        console.error("Tutorial overlay, card, or text element not found");
    }
}

function hideTutorialMessage(callback) {
    const overlay = document.getElementById("tutorial-overlay");
    const card = document.getElementById("tutorial-card");
    if (overlay && card) {
        card.classList.remove("visible"); // Slide down
        setTimeout(() => {
            overlay.classList.remove("visible"); // Deactivate blocker
            card.style.visibility = "hidden";
            overlay.style.visibility = "hidden";
            console.log("Message hidden, bottom: -100vh, opacity: 0, visibility: hidden");
            if (callback) callback(); // Call advance after animation
        }, 500); // Match CSS transition duration (0.5s)
    }
    const openingMenu = document.getElementById("opening-menu");
    if (openingMenu) openingMenu.style.display = "none"; // Reinforce hide
}

function advanceTutorialStep() {
    if (!tutorialMode) return; // Early return if not in tutorial mode
    const openingMenu = document.getElementById("opening-menu");
    if (openingMenu) openingMenu.style.display = "none"; // Ensure menu stays hidden
    if (tutorialStep >= tutorialMessages.length) {
        // Tutorial end: Reset mode and show menu
        tutorialMode = false;
        if (openingMenu) openingMenu.style.display = "flex";
        return;
    }
    console.log(`Advancing to tutorialStep = ${tutorialStep}, showing message: "${tutorialMessages[tutorialStep]}"`);
    showTutorialMessage(tutorialMessages[tutorialStep]);
    // Step-specific setup
    if (tutorialStep === 0) { // Message0 (Welcome1) shown, OK auto-advances to 1
        const rollButton = document.getElementById("roll-button");
        if (rollButton) {
            rollButton.style.pointerEvents = "none"; // Disable roll button
            rollButton.style.opacity = "0.5";
            rollButton.classList.remove("pulsing-roll");
            console.log("Roll button disabled at step 0");
        }
    } else if (tutorialStep === 1) { // Message1 (Welcome2: "There are 9 rounds... Ready to roll?") shown, OK enables roll in tutorialOk
        const rollButton = document.getElementById("roll-button");
        if (rollButton) {
            rollButton.style.pointerEvents = "none"; // Keep disabled
            rollButton.style.opacity = "0.5";
            rollButton.classList.remove("pulsing-roll");
            console.log("Roll button disabled at step 1");
        }
    } else if (tutorialStep === 3) { // Message3 ("Let's dig...") shown, activate highlights and disable dig button
        tutorialAllowedCells = [6, 16, 24, 25, 26, 27]; // Cells: [0,6], [1,6], [2,4], [2,5], [2,6], [2,7]
        document.querySelectorAll(".cell").forEach(cell => {
            const idx = parseInt(cell.dataset.index);
            if (tutorialAllowedCells.includes(idx)) {
                cell.classList.add("tutorial-highlight");
            } else if (!cell.classList.contains("disabled")) {
                cell.classList.add("no-pointer"); // Restrict others
            }
        });
        const digButton = document.getElementById("dig-button");
        if (digButton) {
            digButton.style.pointerEvents = "none"; // Disable dig button
            digButton.style.opacity = "0.5";
            console.log("Dig button disabled at step 3");
        }
        updateDigButtonState(); // Ensure state consistency
    } else if (tutorialStep === 6) { // Message6 ("Dig patterns...") shown, activate new highlights and disable dig button
        tutorialAllowedCells = [34, 35, 37, 45, 46, 47]; // Corrected: [3,4], [3,5], [3,7], [4,5], [4,6], [4,7] 0-based
        document.querySelectorAll(".cell").forEach(cell => {
            const idx = parseInt(cell.dataset.index);
            if (tutorialAllowedCells.includes(idx)) {
                cell.classList.add("tutorial-highlight");
            } else if (!cell.classList.contains("disabled") && !cell.classList.contains("committed")) {
                cell.classList.add("no-pointer"); // Restrict others (except committed)
            }
        });
        const digButton = document.getElementById("dig-button");
        if (digButton) {
            digButton.style.pointerEvents = "none"; // Disable dig button
            digButton.style.opacity = "0.5";
            console.log("Dig button disabled at step 6");
        }
        updateDigButtonState(); // Ensure state consistency
    } else if (tutorialStep === 9) { // Message9 ("First, let's click... smaller shape") shown, activate highlights for small shape and disable dig button
        tutorialAllowedCells = [56, 66]; // Cells: [5,6]=56, [6,6]=66
        document.querySelectorAll(".cell").forEach(cell => {
            const idx = parseInt(cell.dataset.index);
            if (tutorialAllowedCells.includes(idx)) {
                cell.classList.add("tutorial-highlight");
            } else if (!cell.classList.contains("disabled") && !cell.classList.contains("committed")) {
                cell.classList.add("no-pointer"); // Restrict others (except committed)
            }
        });
        const digButton = document.getElementById("dig-button");
        if (digButton) {
            digButton.style.pointerEvents = "none"; // Disable dig button
            digButton.style.opacity = "0.5";
            console.log("Dig button disabled at step 9");
        }
        updateDigButtonState(); // Ensure state consistency
    } else if (tutorialStep === 11) { // Message11 ("Nice lock...") shown, activate new highlights and disable dig button
        tutorialAllowedCells = [67, 77, 87]; // Cells: [6,7]=67, [7,7]=77, [8,7]=87
        document.querySelectorAll(".cell").forEach(cell => {
            const idx = parseInt(cell.dataset.index);
            if (tutorialAllowedCells.includes(idx)) {
                cell.classList.add("tutorial-highlight");
            } else if (!cell.classList.contains("disabled") && !cell.classList.contains("committed")) {
                cell.classList.add("no-pointer"); // Restrict others (except committed)
            }
        });
        const digButton = document.getElementById("dig-button");
        if (digButton) {
            digButton.style.pointerEvents = "none"; // Disable dig button
            digButton.style.opacity = "0.5";
            console.log("Dig button disabled at step 11");
        }
        updateDigButtonState(); // Ensure state consistency
    } else if (tutorialStep === 13) { // Message13 (new message 14) shown, activate highlights and disable dig button
        tutorialAllowedCells = [55, 65, 75, 85, 86]; // [5,5], [6,5], [7,5], [8,5], [8,6]
        document.querySelectorAll(".cell").forEach(cell => {
            const idx = parseInt(cell.dataset.index);
            if (tutorialAllowedCells.includes(idx)) {
                cell.classList.add("tutorial-highlight");
            } else if (!cell.classList.contains("disabled") && !cell.classList.contains("committed")) {
                cell.classList.add("no-pointer"); // Restrict others (except committed)
            }
        });
        const digButton = document.getElementById("dig-button");
        if (digButton) {
            digButton.style.pointerEvents = "none"; // Disable dig button
            digButton.style.opacity = "0.5";
            console.log("Dig button disabled at step 13");
        }
        updateDigButtonState(); // Ensure state consistency
    } else if (tutorialStep === 14) { // Message14 (new message 15) shown, highlight single cell and disable dig button
        tutorialAllowedCells = [44]; // [4,4]
        document.querySelectorAll(".cell").forEach(cell => {
            const idx = parseInt(cell.dataset.index);
            if (tutorialAllowedCells.includes(idx)) {
                cell.classList.add("tutorial-highlight");
            } else if (!cell.classList.contains("disabled") && !cell.classList.contains("committed")) {
                cell.classList.add("no-pointer"); // Restrict others (except committed)
            }
        });
        const digButton = document.getElementById("dig-button");
        if (digButton) {
            digButton.style.pointerEvents = "none"; // Disable dig button
            digButton.style.opacity = "0.5";
            console.log("Dig button disabled at step 14");
        }
        updateDigButtonState(); // Ensure state consistency
    } else if (tutorialStep === 15) { // Message15 (new message 16) shown, enable roll button
        const rollButton = document.getElementById("roll-button");
        if (rollButton) {
            rollButton.style.pointerEvents = "auto"; // Enable roll button
            rollButton.style.opacity = "1";
            rollButton.classList.add("pulsing-roll");
            console.log("Roll button enabled at step 15 (after showing message 15)");
        }
    } else if (tutorialStep === 17) { // After showing message 17 (18 1-based), highlight cells for green 2 and disable dig
        tutorialAllowedCells = [83, 93, 94, 95, 96]; // [8,3], [9,3], [9,4], [9,5], [9,6]
        document.querySelectorAll(".cell").forEach(cell => {
            const idx = parseInt(cell.dataset.index);
            if (tutorialAllowedCells.includes(idx)) {
                cell.classList.add("tutorial-highlight");
            } else if (!cell.classList.contains("disabled") && !cell.classList.contains("committed")) {
                cell.classList.add("no-pointer"); // Restrict others
            }
        });
        const digButton = document.getElementById("dig-button");
        if (digButton) {
            digButton.style.pointerEvents = "none"; // Disable dig button
            digButton.style.opacity = "0.5";
            console.log("Dig button disabled at step 17");
        }
        updateDigButtonState(); // Ensure state consistency
    } else if (tutorialStep === 18) { // After showing message 18 (19 1-based), no additional setup needed (cells already highlighted)
        // nothing
    }
    tutorialStep++;
}

function updateCellCursors() {
	const unclickableCells = digSheetConfigs[currentDigSheet].unclickableCells;
	document.querySelectorAll(".cell").forEach((cell) => {
		const index = parseInt(cell.dataset.index);
		if (
			committedCells.has(index) ||
			unclickableCells.has(index) ||
			gamePhase !== "dig"
		) {
			cell.classList.add("no-pointer");
		} else {
			cell.classList.remove("no-pointer");
		}
	});
}
function toggleCell(index, cellElement) {
    if (tutorialMode && tutorialAllowedCells.length > 0 && !tutorialAllowedCells.includes(index)) {
        return; // Restrict to allowed cells
    }
    const unclickableCells = digSheetConfigs[currentDigSheet].unclickableCells;
    if (committedCells.has(index) || unclickableCells.has(index)) return;
    // Hide NG bonus divs when a cell is clicked
    document.querySelectorAll(".ng-bonus").forEach((div) => {
        div.style.display = "none";
        div.classList.remove("pulsing-ng-bonus");
    });
    if (bonusDigMode) {
        if (selectedCells.has(index)) {
            selectedCells.delete(index);
        } else {
            selectedCells.clear(); // Only one cell allowed in bonus mode
            selectedCells.add(index);
        }
        updatePolyominoOutline();
        playSound("click");
        updateDigButtonState();
        updateNgCrossoffState();
        return;
    }
    let handled = false;
    if (selectedCells.has(index)) {
        // Lock the group containing this index from selectedCells
        const visited = new Set();
        const group = new Set();
        dfs(index, group, visited, selectedCells);
        if (group.size > 0) {
            lockedGroups.push(group);
            group.forEach((i) => selectedCells.delete(i));
            handled = true;
            // Tutorial: Detect lock for step 10 to advance to 11
            if (tutorialMode && tutorialStep === 11 && lockedGroups.length === 1) {
                const lockedArray = Array.from(lockedGroups[0]).sort((a, b) => a - b);
                const targetArray = [56, 66].sort((a, b) => a - b);
                if (JSON.stringify(lockedArray) === JSON.stringify(targetArray)) {
                    advanceTutorialStep(); // Show message11
                    console.log("Locked small shape, advanced to step 12");
                }
            }
        }
    } else {
        // Check if in a locked group
        for (let gi = 0; gi < lockedGroups.length; gi++) {
            if (lockedGroups[gi].has(index)) {
                // Clear this locked group
                lockedGroups.splice(gi, 1);
                handled = true;
                break;
            }
        }
    }
    if (!handled) {
        // Toggle in selectedCells
        if (selectedCells.has(index)) {
            selectedCells.delete(index);
        } else {
            selectedCells.add(index);
        }
    }
    updatePolyominoOutline();
    playSound("click");
    updateDigButtonState();
    updateNgCrossoffState();
}
function isConnectedGraph() {
	const allSelected = new Set(selectedCells);
	lockedGroups.forEach((g) => g.forEach((i) => allSelected.add(i)));
	if (allSelected.size === 0) return false;
	const allCells = new Set([...allSelected, ...committedCells.keys()]);
	if (bonusDigMode) {
		if (allSelected.size !== 1) return false;
		const index = allSelected.values().next().value;
		const row = Math.floor(index / 10);
		const col = index % 10;
		if (committedCells.size === 0) return row === 0; // First dig must be in top row
		const directions = [
			[-1, 0],
			[1, 0],
			[0, -1],
			[0, 1]
		];
		return directions.some(([dx, dy]) => {
			const newRow = row + dx;
			const newCol = col + dy;
			if (newRow >= 0 && newRow < 10 && newCol >= 0 && newCol < 10) {
				return committedCells.has(newRow * 10 + newCol);
			}
			return false;
		});
	}
	if (committedCells.size === 0) {
		const hasTopRow = Array.from(allSelected).some(
			(index) => Math.floor(index / 10) === 0
		);
		if (!hasTopRow) return false;
	}
	const visited = new Set();
	const group = new Set();
	const startIndex = allCells.values().next().value;
	dfs(startIndex, group, visited, allCells);
	return group.size === allCells.size;
}

function enterBonusDigMode() {
    bonusDigMode = true;
    selectedCells.clear();
    lockedGroups = [];
    updatePolyominoOutline();
    const digButton = document.getElementById("dig-button");
    const rollButton = document.getElementById("roll-button");
    // Map oil bonus queue index to oil-square ID
    const oilSquareMap = {
        0: "oil-square-1", // 2nd oil
        1: "oil-square-2", // 4th oil
        2: "oil-square-3", // 5th oil
        3: "oil-square-4", // 6th oil
        4: "oil-square-5" // 7th oil (both bonuses)
    };
    const oilSquareId = oilSquareMap[oilBonusQueue[0]];
    if (oilSquareId) {
        const oilSquare = document.getElementById(oilSquareId);
        if (oilSquare) {
            oilSquare.style.display = "flex";
            oilSquare.classList.add("pulsing-oil-square");
        }
    }
    if (digButton) {
        digButton.classList.add("bonus-mode");
        digButton.classList.add("loading");
        digButton.classList.remove("loaded", "pulsing-dig");
        digButton.style.opacity = "0.5";
        digButton.style.pointerEvents = "none";
        digButton.style.animation = "spin 0.5s ease-in-out";
        setTimeout(() => {
            const img = digButton.querySelector("img");
            if (img) img.src = "https://i.imgur.com/ZI42Lkq.png"; // Change image halfway through spin
            digButton.style.animation = ""; // Clear animation after completion
        }, 250); // Halfway through 0.5s spin
    }
    if (rollButton) {
        rollButton.classList.add("loading");
        rollButton.classList.remove("loaded", "pulsing-roll");
        rollButton.style.opacity = "0.5";
        rollButton.style.pointerEvents = "none";
    }
    updateCellCursors();
    playSound("click");
    console.log("Entered bonus dig mode, showed oil square:", oilSquareId);
    // Tutorial: Advance to step 14 to show message14 (new 15) after entering bonus mode and set highlights
    if (tutorialMode && tutorialStep === 14) {
        advanceTutorialStep();
    }
}

function exitBonusDigMode(undo = false) {
    bonusDigMode = false;
    const digButton = document.getElementById("dig-button");
    const rollButton = document.getElementById("roll-button");
    if (digButton) {
        digButton.classList.remove("bonus-mode");
        digButton.classList.add("loading");
        digButton.classList.remove("loaded", "pulsing-dig");
        digButton.style.opacity = "0.5";
        digButton.style.pointerEvents = "none";
        digButton.style.animation = "spin 0.5s ease-in-out";
        setTimeout(() => {
            const img = digButton.querySelector("img");
            if (img) img.src = "https://i.imgur.com/7tDYHqX.png"; // Change image halfway through spin
            digButton.style.animation = ""; // Clear animation after completion
        }, 250); // Halfway through 0.5s spin
    }
    if (!undo && oilBonusQueue.length === 0) {
        gamePhase = rollCount < 9 ? "roll" : "end";
        if (rollButton) {
            rollButton.classList.toggle("loaded", gamePhase === "roll");
            rollButton.classList.toggle("loading", gamePhase !== "roll");
            rollButton.classList.toggle("pulsing-roll", gamePhase === "roll");
            rollButton.style.opacity = gamePhase === "roll" ? "1" : "0.5";
            rollButton.style.pointerEvents = gamePhase === "roll" ? "auto" : "none";
        }
    }
    // NEW: Hide all oil squares and remove pulsing
    document.querySelectorAll(".oil-square, .oil-square-final").forEach((square) => {
        square.style.display = "none";
        square.classList.remove("pulsing-oil-square");
    });
    updateCellCursors();
    playSound("click");
    console.log("Exited bonus dig mode");
}

function updateDigButtonState() {
	const digButton = document.getElementById("dig-button");
	if (!digButton) return;
	if (gamePhase !== "dig") {
		digButton.classList.add("loading");
		digButton.classList.remove("loaded", "pulsing-dig");
		digButton.style.opacity = "0.5";
		digButton.style.pointerEvents = "none";
		if (bonusDigMode) {
			digButton.classList.add("bonus-mode");
		} else {
			digButton.classList.remove("bonus-mode");
		}
		return;
	}
	const allNewSize =
		selectedCells.size + lockedGroups.reduce((acc, g) => acc + g.size, 0);
	const isValid = bonusDigMode
		? allNewSize === 1 && isConnectedGraph()
		: allNewSize > 0 &&
		  isConnectedGraph() &&
		  (allNewSize === 1 || isValidPattern());
	console.log(
		`Dig button state: allNewSize=${allNewSize}, connected=${isConnectedGraph()}, validPattern=${isValidPattern()}, bonusDigMode=${bonusDigMode}`
	);
	if (isValid) {
		digButton.classList.remove("loading");
		digButton.classList.add("loaded", "pulsing-dig");
		digButton.classList.remove("bonus-mode"); // Remove bonus-mode to avoid spin animation conflict
		digButton.style.opacity = "1";
		digButton.style.pointerEvents = "auto";
		if (bonusDigMode) {
			const img = digButton.querySelector("img");
			if (img) img.src = "https://i.imgur.com/ZI42Lkq.png"; // Ensure bonus image
		}
	} else {
		digButton.classList.add("loading");
		digButton.classList.remove("loaded", "pulsing-dig");
		if (bonusDigMode) {
			digButton.classList.add("bonus-mode");
		} else {
			digButton.classList.remove("bonus-mode");
		}
		digButton.style.opacity = "0.5";
		digButton.style.pointerEvents = "none";
	}
}
document.addEventListener("DOMContentLoaded", () => {
	preloadImages().then(() => {
		// Function to handle click animation
		function applyClickAnimation(button) {
			if (button) {
				button.classList.add("clicked");
				setTimeout(() => {
					button.classList.remove("clicked");
				}, 25); // 25ms for scale down and back up
			}
		}
		const rollButton = document.getElementById("roll-button");
		if (rollButton) {
			rollButton.addEventListener("click", () => {
				rollDice();
				applyClickAnimation(rollButton);
			});
		}
		const digButton = document.getElementById("dig-button");
		if (digButton) {
			digButton.addEventListener("click", () => {
				commitPolyomino();
				applyClickAnimation(digButton);
			});
		}
		const undoButton = document.getElementById("undo-button");
		if (undoButton) {
			undoButton.addEventListener("click", () => {
				undoLastCommit();
				applyClickAnimation(undoButton);
			});
		}

		const leftButton = document.getElementById("left-button");
		if (leftButton) leftButton.addEventListener("click", scrollLeft);
		const rightButton = document.getElementById("right-button");
		if (rightButton) rightButton.addEventListener("click", scrollRight);

		const digSheetSwitcher = document.getElementById("dig-sheet-switcher");
		if (digSheetSwitcher) {
			digSheetSwitcher.addEventListener("click", () => {
				switchDigSheet();
				applyClickAnimation(digSheetSwitcher);
			});
		}
		const rollSheetSwitcher = document.getElementById("roll-sheet-switcher");
		if (rollSheetSwitcher) {
			rollSheetSwitcher.addEventListener("click", () => {
				switchRollSheet();
				applyClickAnimation(rollSheetSwitcher);
			});
		}
		// Updated Free Play button listener (complete block, for consistency)
const freePlayButton = document.getElementById("free-play-button");
if (freePlayButton) {
    freePlayButton.replaceWith(freePlayButton.cloneNode(true));
    const newFreePlayButton = document.getElementById("free-play-button");
    newFreePlayButton.addEventListener("click", () => {
        const freePlaySubmenu = document.getElementById("free-play-submenu");
        const mainMenuElements = [
            document.getElementById("free-play-button"),
            document.getElementById("daily-challenge-button"),
            document.getElementById("daily-challenge-timer"),
            document.getElementById("game-logo")
        ];
        const resumeButton = document.getElementById("resume-button");
        if (!freePlaySubmenu) {
            console.error(
                "Error: #free-play-submenu not found in DOM. Please ensure the sub-menu HTML is inside #opening-menu."
            );
            return;
        }
        console.log("Free Play clicked, showing #free-play-submenu");
        mainMenuElements.forEach((el) => {
            if (el) el.style.display = "none";
        });
        if (resumeButton) resumeButton.style.display = "none"; // Explicitly hide resume in submenu
        freePlaySubmenu.style.display = "flex";
        freePlaySubmenu.style.visibility = "visible";
        freePlaySubmenu.style.opacity = "1";
        initializeSubMenuSelections();
        console.log("Sub-menu styles:", {
            display: freePlaySubmenu.style.display,
            visibility: freePlaySubmenu.style.visibility,
            opacity: freePlaySubmenu.style.opacity,
            zIndex: freePlaySubmenu.style.zIndex
        });
        applyClickAnimation(newFreePlayButton);
    });
}
		
		// Updated Daily Challenge button listener (complete block)
const dailyChallengeButton = document.getElementById(
"daily-challenge-button"
);
if (dailyChallengeButton) {
    dailyChallengeButton.addEventListener("click", () => {
        tutorialMode = false; // Explicitly disable tutorial mode
        gameMode = "daily-challenge";
        document.getElementById("opening-menu").style.display = "none";
        const resumeButton = document.getElementById("resume-button");
        if (resumeButton) resumeButton.style.display = "block";
        startDailyChallenge();
        applyClickAnimation(dailyChallengeButton);
    });
}
		

    // Updated Clearly Sharp button listener (complete block)
const clearlySharpButton = document.getElementById("clearly-sharp-button");
if (clearlySharpButton) {
    clearlySharpButton.replaceWith(clearlySharpButton.cloneNode(true));
    const newClearlySharpButton = document.getElementById("clearly-sharp-button");
    newClearlySharpButton.addEventListener("click", () => {
        const clearlySharpSubmenu = document.getElementById("clearly-sharp-submenu");
        const mainMenuElements = [
            document.getElementById("free-play-button"),
            document.getElementById("daily-challenge-button"),
            document.getElementById("how-to-play-button"),
            document.getElementById("clearly-sharp-button"),
            document.getElementById("daily-challenge-timer"),
            document.getElementById("game-logo")
        ];
        const resumeButton = document.getElementById("resume-button");
        if (!clearlySharpSubmenu) {
            console.error(
                "Error: #clearly-sharp-submenu not found in DOM."
            );
            return;
        }
        console.log("Clearly Sharp clicked, showing #clearly-sharp-submenu");
        mainMenuElements.forEach((el) => {
            if (el) el.style.display = "none";
        });
        if (resumeButton) resumeButton.style.display = "none"; // Explicitly hide resume in submenu
        clearlySharpSubmenu.style.display = "flex";
        clearlySharpSubmenu.style.visibility = "visible";
        clearlySharpSubmenu.style.opacity = "1";
        applyClickAnimation(newClearlySharpButton);
    });
}
		
		// Updated Back button listener for free-play submenu (complete block)
const backButton = document.getElementById("back-button");
if (backButton) {
    backButton.replaceWith(backButton.cloneNode(true));
    const newBackButton = document.getElementById("back-button");
    newBackButton.addEventListener("click", () => {
        const freePlaySubmenu = document.getElementById("free-play-submenu");
        const mainMenuElements = [
            document.getElementById("free-play-button"),
            document.getElementById("daily-challenge-button"),
            document.getElementById("how-to-play-button"),
            document.getElementById("clearly-sharp-button"),
            document.getElementById("daily-challenge-timer"),
            document.getElementById("game-logo")
        ];
        const resumeButton = document.getElementById("resume-button");
        console.log("Back clicked, returning to #opening-menu");
        freePlaySubmenu.style.display = "none";
        mainMenuElements.forEach((el) => {
            if (el) el.style.display = "block";
        });
        if (resumeButton)
            resumeButton.style.display = hasGameState() ? "block" : "none";
        tutorialMode = false; // Reset tutorial mode on return to menu
        applyClickAnimation(newBackButton);
    });
}

    // Remove any old tutorialButton listener (since button is gone)

// Repurpose How to Play button to start tutorial
// Updated How to Play button listener (complete block)
const howToPlayButton = document.getElementById("how-to-play-button");
if (howToPlayButton) {
    howToPlayButton.replaceWith(howToPlayButton.cloneNode(true)); // Clone to clear old listeners if any
    const newHowToPlayButton = document.getElementById("how-to-play-button");
    newHowToPlayButton.addEventListener("click", () => {
        tutorialMode = true;
        gameMode = "tutorial";
        const openingMenu = document.getElementById("opening-menu");
        if (openingMenu) openingMenu.style.display = "none"; // Hide menu
        currentDigSheet = "dig-sheet-a"; // Fixed for tutorial
        currentRollSheet = "roll-sheet-a";
        resetGrid(); // Start fresh
        tutorialStep = 0; // Reset step
        advanceTutorialStep(); // Explicitly start tutorial after reset
        console.log("How to Play started, tutorialMode = true, step = 0");
        playSound("click");
        applyClickAnimation(newHowToPlayButton);
    });
}
		
const tutorialOk = document.getElementById("tutorial-ok");
if (tutorialOk) {
    tutorialOk.addEventListener("click", () => {
        hideTutorialMessage(() => {
            console.log(`OK clicked at tutorialStep = ${tutorialStep}`);
            if (tutorialMode) {
                if (tutorialStep === 1) { // After OK on message0 (Welcome1), auto-advance to 1 (show message1)
                    advanceTutorialStep();
                    console.log("Advanced to step 2 after OK on message0");
                } else if (tutorialStep === 2) { // After OK on message1 (Welcome2), enable roll button, no advance
                    const rollButton = document.getElementById("roll-button");
                    if (rollButton) {
                        rollButton.style.pointerEvents = "auto"; // Enable roll button
                        rollButton.style.opacity = "1";
                        rollButton.classList.add("pulsing-roll");
                        console.log("Roll button enabled at step 2 (after OK on message1)");
                    }
                } else if (tutorialStep === 3) { // Auto-advance after message2 (to3)
                    advanceTutorialStep();
                    console.log("Advanced to step 4 after OK on message2");
                } else if (tutorialStep === 9) { // After OK on message8 (some dig patterns), advance to show message9 (first click build smaller)
                    advanceTutorialStep();
                    console.log("Advanced to step 10 after OK on message8");
                } else if (tutorialStep === 10) { // After OK on message9 (first click build), no advance - wait for selection
                    // nothing
                } else if (tutorialStep === 11) { // After OK on message10 (great prevent lock), no advance - wait for lock
                    // nothing
                } else if (tutorialStep === 12) { // After OK on message11 (nice lock select other), no advance - wait for selection/dig
                    // nothing
                } else if (tutorialStep === 16) { // After OK on message15 (16 1-based), enable roll, no advance (wait for roll)
                    const rollButton = document.getElementById("roll-button");
                    if (rollButton) {
                        rollButton.style.pointerEvents = "auto"; // Enable roll button
                        rollButton.style.opacity = "1";
                        rollButton.classList.add("pulsing-roll");
                        console.log("Roll button enabled at step 16 (after OK on message15)");
                    }
                } else if (tutorialStep === 17) { // After OK on message16 (17 1-based), no advance (wait for NG cross-off)
                    // nothing (cells already disabled in advance for step=17)
                }
            }
        });
        playSound("click");
    });
}
		
		

// Keep your existing tutorial-ok listener unchanged

    // Updated Back button listener for clearly-sharp submenu (complete block)
const backClearlySharpButton = document.getElementById("back-clearly-sharp");
if (backClearlySharpButton) {
    backClearlySharpButton.replaceWith(backClearlySharpButton.cloneNode(true));
    const newBackClearlySharpButton = document.getElementById("back-clearly-sharp");
    newBackClearlySharpButton.addEventListener("click", () => {
        const clearlySharpSubmenu = document.getElementById("clearly-sharp-submenu");
        const mainMenuElements = [
            document.getElementById("free-play-button"),
            document.getElementById("daily-challenge-button"),
            document.getElementById("how-to-play-button"),
            document.getElementById("clearly-sharp-button"),
            document.getElementById("daily-challenge-timer"),
            document.getElementById("game-logo")
        ];
        const resumeButton = document.getElementById("resume-button");
        console.log("Back clicked, returning to #opening-menu from Clearly Sharp");
        clearlySharpSubmenu.style.display = "none";
        mainMenuElements.forEach((el) => {
            if (el) el.style.display = "block";
        });
        if (resumeButton)
            resumeButton.style.display = hasGameState() ? "block" : "none";
        tutorialMode = false; // Reset tutorial mode on return to menu
        applyClickAnimation(newBackClearlySharpButton);
    });
}
		
		// Updated Home button listener (complete block)
const homeButton = document.getElementById("home-button");
if (homeButton) {
    homeButton.addEventListener("click", () => {
        const openingMenu = document.getElementById("opening-menu");
        const resumeButton = document.getElementById("resume-button");
        if (!openingMenu) {
            console.error("Error: #opening-menu not found in DOM.");
            return;
        }
        console.log("Home clicked, showing #opening-menu");
        openingMenu.style.display = "flex";
        const mainMenuElements = [
            document.getElementById("free-play-button"),
            document.getElementById("daily-challenge-button"),
            document.getElementById("daily-challenge-timer"),
            document.getElementById("game-logo")
        ];
        mainMenuElements.forEach((el) => {
            if (el) el.style.display = "";
        });
        if (resumeButton)
            resumeButton.style.display = hasGameState() ? "block" : "none";
        tutorialMode = false; // Reset tutorial mode on return to menu
        playSound("click");
        applyClickAnimation(homeButton);
    });
}
		const resumeButton = document.getElementById("resume-button");
		if (resumeButton) {
			resumeButton.addEventListener("click", () => {
				const openingMenu = document.getElementById("opening-menu");
				if (!openingMenu) {
					console.error("Error: #opening-menu not found in DOM.");
					return;
				}
				console.log("Resume clicked, hiding #opening-menu");
				openingMenu.style.display = "none";
				playSound("click");
				applyClickAnimation(resumeButton);
			});
		}
		
		// Updated Play button listener (complete block, for free-play start)
const playButton = document.getElementById("play-button");
if (playButton) {
    playButton.addEventListener("click", () => {
        if (selectedDigSheet && selectedRollSheet) {
            tutorialMode = false; // Explicitly disable tutorial mode
            gameMode = "free-play";
            currentDigSheet = selectedDigSheet;
            currentRollSheet = selectedRollSheet;
            const digSheetElement = document.getElementById("dig-sheet");
            const overlayImg = document.querySelector("#dig-sheet-overlay img");
            const rollSheetImg = document
                .getElementById("roll-sheet")
                .querySelector("img:not(#green-image img):not(#white-image img)");
            const openingMenu = document.getElementById("opening-menu");
            const resumeButton = document.getElementById("resume-button");
            const homeButton = document.getElementById("home-button");
            if (!digSheetElement || !overlayImg || !rollSheetImg || !openingMenu) {
                console.error("Error: Missing game elements", {
                    digSheetElement,
                    overlayImg,
                    rollSheetImg,
                    openingMenu
                });
                return;
            }
            console.log("Play clicked, setting sheets:", {
                currentDigSheet,
                currentRollSheet
            });
            digSheetElement.style.backgroundImage = `url(${digSheetBackgroundImages[currentDigSheet]})`;
            overlayImg.src = digSheetOverlayImages[currentDigSheet];
            rollSheetImg.src = rollSheetImages[currentRollSheet];
            // Set default dice images (6 for both green and white)
            greenImage.innerHTML = `<img src="${imageMap[currentRollSheet].green[6]}" alt="Die Image">`;
            whiteImage.innerHTML = `<img src="${imageMap[currentRollSheet].white[6]}" alt="Die Image">`;
            die1.setAttribute("data-value", "6");
            die2.setAttribute("data-value", "6");
            // Update boulder positions
            const boulderElements = document.querySelectorAll(".boulder-cross-off");
            boulderElements.forEach((element, index) => {
                const config = digSheetBoulderConfigs[currentDigSheet][index];
                if (config) {
                    element.style.top = config.top;
                    element.style.left = config.left;
                }
            });
            // Hide opening menu
            openingMenu.style.display = "none";
            freePlaySubmenu.style.display = "none";
            if (resumeButton) resumeButton.style.display = "block";
            if (homeButton) {
                homeButton.classList.remove("loading");
                homeButton.classList.add("loaded");
            }
            // Force redraw
            requestAnimationFrame(() => {
                digSheetElement.offsetHeight;
                rollSheetImg.offsetHeight;
                console.log("Dig sheet and roll sheet redrawn", {
                    digSheetBackground: digSheetElement.style.backgroundImage,
                    overlayImage: overlayImg.src,
                    rollSheetImage: rollSheetImg.src
                });
            });
            resetGrid();
            playSound("click");
        }
    });
}
		// Updated Random button listener (complete block, for random free-play start)
const randomButton = document.getElementById("random-button");
if (randomButton) {
    randomButton.addEventListener("click", () => {
        tutorialMode = false; // Explicitly disable tutorial mode
        const digSheetsList = [
            "dig-sheet-a",
            "dig-sheet-b",
            "dig-sheet-c",
            "dig-sheet-d",
            "dig-sheet-e",
            "dig-sheet-f",
            "dig-sheet-g",
            "dig-sheet-h"
        ];
        const rollSheetsList = ["roll-sheet-a", "roll-sheet-b"];
        selectedDigSheet =
            digSheetsList[Math.floor(Math.random() * digSheetsList.length)];
        currentDigSheet = selectedDigSheet;
        selectedRollSheet =
            rollSheetsList[Math.floor(Math.random() * rollSheetsList.length)];
        currentRollSheet = selectedRollSheet;
        const digSheetElement = document.getElementById("dig-sheet");
        const overlayImg = document.querySelector("#dig-sheet-overlay img");
        const rollSheetImg = document
            .getElementById("roll-sheet")
            .querySelector("img:not(#green-image img):not(#white-image img)");
        const openingMenu = document.getElementById("opening-menu");
        const resumeButton = document.getElementById("resume-button");
        const homeButton = document.getElementById("home-button");
        if (!digSheetElement || !overlayImg || !rollSheetImg || !openingMenu) {
            console.error("Error: Missing game elements", {
                digSheetElement,
                overlayImg,
                rollSheetImg,
                openingMenu
            });
            return;
        }
        console.log("Random clicked, setting sheets:", {
            currentDigSheet,
            currentRollSheet
        });
        digSheetElement.style.backgroundImage = `url(${digSheetBackgroundImages[currentDigSheet]})`;
        overlayImg.src = digSheetOverlayImages[currentDigSheet];
        rollSheetImg.src = rollSheetImages[currentRollSheet];
        // Set default dice images (6 for both green and white)
        greenImage.innerHTML = `<img src="${imageMap[currentRollSheet].green[6]}" alt="Die Image">`;
        whiteImage.innerHTML = `<img src="${imageMap[currentRollSheet].white[6]}" alt="Die Image">`;
        die1.setAttribute("data-value", "6");
        die2.setAttribute("data-value", "6");
        // Update boulder positions
        const boulderElements = document.querySelectorAll(".boulder-cross-off");
        boulderElements.forEach((element, index) => {
            const config = digSheetBoulderConfigs[currentDigSheet][index];
            if (config) {
                element.style.top = config.top;
                element.style.left = config.left;
            }
        });
        // Hide opening menu to reveal game-container (already visible underneath)
        openingMenu.style.display = "none";
        freePlaySubmenu.style.display = "none";
        if (resumeButton) resumeButton.style.display = "block";
        if (homeButton) {
            homeButton.classList.remove("loading");
            homeButton.classList.add("loaded");
        }
        // Force redraw of dig sheet and roll sheet
        requestAnimationFrame(() => {
            digSheetElement.offsetHeight;
            rollSheetImg.offsetHeight;
            console.log("Dig sheet and roll sheet redrawn", {
                digSheetBackground: digSheetElement.style.backgroundImage,
                overlayImage: overlayImg.src,
                rollSheetImage: rollSheetImg.src
            });
        });
        resetGrid();
        playSound("click");
    });
}

		// New consolidated declarations and logic for the finish/screenshot feature
		const finishButton = document.getElementById("finish-button");
		const screenshotButton = document.getElementById("screenshot-button");
		const finalScoreBubble = document.getElementById("final-score-bubble");
		const screenshotExplainer = document.getElementById("screenshot-explainer");

		// Updated animateCountUp with rapid "click" sound every 10ms
		function animateCountUp(targetElement, targetNumber, duration = 1000) {
			let start = 0;
			const step = targetNumber / (duration / 3); // ~3ms per increment (adjust for speed)
			const startTime = performance.now();
			let lastSoundTime = 0; // Throttle sound

			function update(time) {
				const progress = (time - startTime) / duration;
				const current = Math.min(Math.floor(progress * targetNumber), targetNumber);
				targetElement.textContent = current;

				// Play "click" sound every 10ms if time has passed
				if (time - lastSoundTime >= 50) {
					playSound("click");
					lastSoundTime = time;
				}

				if (current < targetNumber) {
					requestAnimationFrame(update);
				}
			}

			requestAnimationFrame(update);
		}

		// "Finish" button logic
		if (finishButton) {
			finishButton.addEventListener("click", () => {
				// Duplicate sum logic for totalScore
				let totalScore = 0;
				totalScore +=
					parseInt(document.getElementById("diamond-score-readout")?.textContent) ||
					0;
				totalScore +=
					parseInt(document.getElementById("silver-score-readout")?.textContent) ||
					0;
				totalScore +=
					parseInt(document.getElementById("lapis-score-readout")?.textContent) || 0;
				totalScore +=
					parseInt(document.getElementById("peridot-score-readout")?.textContent) ||
					0;
				totalScore +=
					parseInt(document.getElementById("topaz-score-readout")?.textContent) || 0;
				totalScore +=
					parseInt(document.getElementById("opal-score-readout")?.textContent) || 0;
				totalScore +=
					parseInt(document.getElementById("amber-score-readout")?.textContent) || 0;
				totalScore +=
					parseInt(document.getElementById("q-s-c-score-readout")?.textContent) || 0;
				if (quartzBonus) totalScore += 6;
				if (sandstoneBonus) totalScore += 9;
				if (coalBonus) totalScore += 13;
				// Slide down Finish button
				finishButton.style.animation = "slide-down 0.5s forwards";
				// Slide up final-score-bubble and start spin/scale + count-up
				finalScoreBubble.classList.remove("hidden-state");
				finalScoreBubble.style.animation =
					"slide-up 0.5s forwards, spin-scale .75s cubic-bezier(0.8, 0, 0.2, 1.0)";
				finalScoreBubble.style.paddingRight = ".3cqh";
				animateCountUp(finalScoreBubble, totalScore, 1000); // 1s count-up
				// After 1s, slide bubble right, slide up Screenshot button, fade in explainer
				setTimeout(() => {
					playSound("bonus");
					finalScoreBubble.style.animation = "slide-right 0.5s forwards";
					// After slide-right completes, clear animation and lock visibility/position
					setTimeout(() => {
						finalScoreBubble.style.animation = ""; // Clear to prevent conflicts
						finalScoreBubble.style.opacity = "1"; // Force visible
						finalScoreBubble.style.left = "calc(50% + 21.3cqh)"; // Lock right position (center shifted 21.6dvh right)
						finalScoreBubble.style.bottom = "8.3cqh"; // Lock vertical center alignment
						finalScoreBubble.style.transform = "translateX(-50%)"; // Keep centered at new left
						finalScoreBubble.classList.remove("hidden-state"); // Ensure no hidden class
						// Fade in screenshot-explainer
						screenshotExplainer.classList.remove("hidden-state");
						screenshotExplainer.style.animation = "fade-in 0.5s forwards";
					}, 500); // After slide-right 0.5s
					screenshotButton.classList.remove("off-screen");
					screenshotButton.style.animation = "slide-up-button 0.5s forwards"; // Button-specific slide-up
				}, 1000 + 1000); // Wait for count-up + 1s pause
				playSound("click");
			});
		}

		// "Screenshot" button logic (triggers your existing screenshot overlay)
		if (screenshotButton) {
			screenshotButton.addEventListener("click", () => {
				const digClone = digSheet.cloneNode(true);
				digClone.id = "dig-sheet-clone";
				// Explicit styles for container fill
				digClone.style.position = "absolute";
				digClone.style.top = "0";
				digClone.style.left = "0";
				digClone.style.width = "100%";
				digClone.style.height = "75dvh";
				digClone.style.overflow = "hidden";

				// Access nested overlay in clone
				const nestedOverlay = digClone.querySelector("#dig-sheet-overlay");
				if (nestedOverlay) {
					nestedOverlay.style.width = "100%";
					nestedOverlay.style.height = "75dvh";
					nestedOverlay.style.pointerEvents = "none";
				}

				// Hide buttons/nav in the clone
				const buttonsToHide = digClone.querySelectorAll(
					"#home-button, #dig-button, #undo-button, .return-button, .nav-button"
				);
				buttonsToHide.forEach((btn) => (btn.style.display = "none"));

				// NEW: Disable and hide dig-sheet-switcher in clone (no hover/click)
				const switcherClone = digClone.querySelector("#dig-sheet-switcher");
				if (switcherClone) {
					switcherClone.style.pointerEvents = "none";
					switcherClone.style.opacity = "0"; // Or "display: none;" if you want it completely gone
				}

				// Hide polyomino SVGs
				const svgsToHide = digClone.querySelectorAll(".polyomino-svg");
				svgsToHide.forEach((svg) => (svg.style.display = "none"));

				// Replace bg-image with full-res <img> for crisp raster
				const bgImg = document.createElement("img");
				bgImg.src = digSheetBackgroundImages[currentDigSheet];
				bgImg.style.position = "absolute";
				bgImg.style.top = "0";
				bgImg.style.left = "0";
				bgImg.style.width = "100%";
				bgImg.style.height = "100%";
				bgImg.style.objectFit = "contain";
				bgImg.style.zIndex = "-1";
				bgImg.style.pointerEvents = "none";
				digClone.insertBefore(bgImg, digClone.firstChild);

				// Clear original bg-image
				digClone.style.backgroundImage = "none";

				// Grid placeholder
				const gridPlaceholder = digClone.querySelector(".grid-placeholder");
				if (gridPlaceholder) {
					gridPlaceholder.style.position = "absolute";
				}

				const scoreBgDiv = document.createElement("div");
				scoreBgDiv.id = "score-bg-div";
				scoreBgDiv.style.position = "absolute";
				scoreBgDiv.style.top = "77dvh"; // Change this number to move scoreBgDiv down (e.g., "80dvh" for more space, "75dvh" for no space)
				scoreBgDiv.style.left = "9dvh";
				scoreBgDiv.style.width = "100%";
				scoreBgDiv.style.height = "10dvh";
				scoreBgDiv.style.overflow = "hidden";
				scoreBgDiv.style.alignItems = "center";

				// Add <img> for badge (full-width, aspect preserved, centered)
				const scoreImg = document.createElement("img");
				scoreImg.src = "https://i.imgur.com/DM8guQA.png";
				scoreImg.style.position = "absolute";
				scoreImg.style.top = "0";
				scoreImg.style.left = "0";
				scoreImg.style.width = "100%";
				scoreImg.style.height = "auto";
				scoreImg.style.objectFit = "contain";
				scoreImg.style.objectPosition = "center";
				scoreBgDiv.appendChild(scoreImg);

				// Create new scoreTextDiv from scratch (child of scoreBgDiv)
				const scoreTextDiv = document.createElement("div");
				scoreTextDiv.id = "score-text-div";
				scoreTextDiv.style.position = "absolute";
				scoreTextDiv.style.top = "0";
				scoreTextDiv.style.left = "-.4dvh";
				scoreTextDiv.style.width = "100%";
				scoreTextDiv.style.height = "100%";
				scoreTextDiv.style.display = "flex";
				scoreTextDiv.style.justifyContent = "center";
				scoreTextDiv.style.alignItems = "center";
				scoreTextDiv.style.paddingTop = "0.5dvh"; // Change this number to nudge the number down (e.g., "2dvh" for more down, "0dvh" for none)
				scoreTextDiv.style.paddingLeft = ".3cqh"; // Change this number to nudge the number left (e.g., "2dvh" for more left, "0dvh" for none)
				scoreTextDiv.style.zIndex = "40"; // High for above img
				scoreTextDiv.style.color = "black";
				scoreTextDiv.style.fontSize = "4dvh";
				scoreTextDiv.style.fontFamily = '"Covered By Your Grace", cursive';
				scoreTextDiv.style.opacity = "1";
				scoreTextDiv.style.visibility = "visible";

				// Duplicate sum logic from updateFinalScore() for screenshot total
				let totalScore = 0;
				totalScore +=
					parseInt(document.getElementById("diamond-score-readout")?.textContent) ||
					0;
				totalScore +=
					parseInt(document.getElementById("silver-score-readout")?.textContent) ||
					0;
				totalScore +=
					parseInt(document.getElementById("lapis-score-readout")?.textContent) || 0;
				totalScore +=
					parseInt(document.getElementById("peridot-score-readout")?.textContent) ||
					0;
				totalScore +=
					parseInt(document.getElementById("topaz-score-readout")?.textContent) || 0;
				totalScore +=
					parseInt(document.getElementById("opal-score-readout")?.textContent) || 0;
				totalScore +=
					parseInt(document.getElementById("amber-score-readout")?.textContent) || 0;
				totalScore +=
					parseInt(document.getElementById("q-s-c-score-readout")?.textContent) || 0;
				if (quartzBonus) totalScore += 6;
				if (sandstoneBonus) totalScore += 9;
				if (coalBonus) totalScore += 13;

				// Set the score text from calculated total
				scoreTextDiv.textContent = totalScore === 0 ? "" : totalScore;

				// Append to scoreBgDiv
				scoreBgDiv.appendChild(scoreTextDiv);

				const dateDiv = document.createElement("div");
				dateDiv.style.position = "absolute";
				dateDiv.style.top = "77.5dvh"; // Same as scoreBgDiv
				dateDiv.style.left = "-5.5dvh";
				dateDiv.style.width = "50%";
				dateDiv.style.height = "10dvh";
				dateDiv.style.display = "flex";
				dateDiv.style.flexDirection = "column";
				dateDiv.style.justifyContent = "center";
				dateDiv.style.alignItems = "center";
				dateDiv.style.fontFamily = '"Covered By Your Grace", cursive';
				dateDiv.style.fontSize = "3.5dvh";
				dateDiv.style.color = "black";
				dateDiv.style.textAlign = "center";
				dateDiv.style.zIndex = "50";
				dateDiv.style.pointerEvents = "none";

				// Get current date in format "Month <br> 05 / 2025"
				const months = [
					"January",
					"February",
					"March",
					"April",
					"May",
					"June",
					"July",
					"August",
					"September",
					"October",
					"November",
					"December"
				];

				const now = new Date();
				const month = months[now.getMonth()];
				const day = now.getDate().toString().padStart(2, "0");
				const year = now.getFullYear();
				dateDiv.innerHTML = `${month}<br>${day} / ${year}`;

				// NEW: Add game logo <img> centered near top of screenshot
				const logoImg = document.createElement("img");
				logoImg.src = "https://i.imgur.com/H1v1du8.png";
				logoImg.style.position = "absolute";
				logoImg.style.top = "1.5dvh"; // Change this to nudge up/down (lower number moves up, higher moves down)
				logoImg.style.left = "50%";
				logoImg.style.transform = "translateX(-50%)"; // Center horizontally
				logoImg.style.width = "17dvh"; // Change this for size (e.g., "25dvh" for larger, "15dvh" for smaller)
				logoImg.style.height = "auto"; // Preserve aspect
				logoImg.style.zIndex = "50"; // Above dig sheet
				logoImg.style.pointerEvents = "none";

				// Append to container
				screenshotContainer.innerHTML = "";
				screenshotContainer.appendChild(digClone);
				screenshotContainer.appendChild(logoImg); // Add logo after digClone
				screenshotContainer.appendChild(dateDiv); // Add date on left
				screenshotContainer.appendChild(scoreBgDiv);

				// Reflow
				screenshotContainer.offsetHeight;

				// Show overlay
				endGameOverlay.classList.remove("hidden");

				playSound("click");
			});
		}

		// Selectors for cloning and overlay
		const digSheet = document.getElementById("dig-sheet");
		const digSheetOverlay = document.getElementById("dig-sheet-overlay");
		const finalScore = document.getElementById("final-score");
		const endGameOverlay = document.getElementById("end-game-overlay");
		const screenshotContainer = document.getElementById("screenshot-container");

		// Close overlay on outside click or ESC (optional UX polish)
		if (endGameOverlay) {
			endGameOverlay.addEventListener("click", () => {
				endGameOverlay.classList.add("hidden");
				screenshotContainer.innerHTML = ""; // Clean clones
			});
		}

		document.addEventListener("keydown", (e) => {
			if (e.key === "Escape" && !endGameOverlay.classList.contains("hidden")) {
				endGameOverlay.classList.add("hidden");
				screenshotContainer.innerHTML = "";
			}
		});

		updateDailyChallengeTimer();
		window.addEventListener("beforeunload", (event) => {
			if (hasGameState()) {
				event.preventDefault();
				event.returnValue = "";
			}
		});
	});
	updateView();
	
function setVH() {
    setTimeout(() => { // Async for reflow
      const vh = (window.visualViewport ? window.visualViewport.height : window.innerHeight) * 0.01;
      document.documentElement.style.setProperty('--vh', `${vh}px`);
      document.body.style.zoom = '1'; // Reset any persisted zoom
    }, 0);
  }
  setVH(); // Set on initial load
  // Force address bar hide with progressive scroll (handles stubborn cases)
  function hideAddressBar() {
    setTimeout(() => {
      if (window.pageYOffset === 0) {
        window.scrollTo(0, 1);
        setTimeout(() => window.scrollTo(0, 0), 0); // Reset to top
      }
      setVH(); // Recalc after hide
    }, 100);
  }
  hideAddressBar(); // Run on load
  window.addEventListener('resize', () => {
    setVH();
    hideAddressBar();
  });
  window.addEventListener('orientationchange', () => {
    setVH();
    hideAddressBar();
  });
  window.addEventListener('pageshow', (event) => {
    if (event.persisted) { // bfcache restore (tab reopen)
      setVH();
      hideAddressBar();
    }
  });
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible') { // Tab becomes active
      setVH();
      hideAddressBar();
    }
  });
  // Listen directly to visualViewport resize (key for bar changes)
  if (window.visualViewport) {
    window.visualViewport.addEventListener('resize', () => {
      setVH();
      hideAddressBar();
    });
  }
});

updateView(); // Set starting view
const leftButton = document.getElementById("left-button");
if (leftButton) leftButton.addEventListener("click", scrollLeft);
const rightButton = document.getElementById("right-button");
if (rightButton) rightButton.addEventListener("click", scrollRight);

updateButtons();

const gameContainer = document.getElementById("game-container");
if (gameContainer && typeof Hammer !== 'undefined') {
  const hammer = new Hammer(gameContainer);
  hammer.get('swipe').set({ direction: Hammer.DIRECTION_HORIZONTAL }); // Restrict to left/right swipes only
  
  hammer.on('swiperight', () => {
    scrollLeft(); // Swipe right -> left button action (go left/previous)
  });
  
  hammer.on('swipeleft', () => {
    scrollRight(); // Swipe left -> right button action (go right/next)
  });
}

const grid = document.getElementById("grid");
for (let i = 0; i < 100; i++) {
	const cell = document.createElement("div");
	cell.classList.add("cell");
	if (digSheetConfigs[currentDigSheet].unclickableCells.has(i))
		cell.classList.add("disabled");
	cell.dataset.index = i;
	grid.appendChild(cell);
}
grid.addEventListener("click", (e) => {
	if (
		e.target.classList.contains("cell") &&
		!e.target.classList.contains("disabled")
	) {
		const index = parseInt(e.target.dataset.index);
		toggleCell(index, e.target);
	}
});
document
	.querySelectorAll(".quartz-circle-clicker")
	.forEach((clicker, index) => {
		quartzClickers.push(clicker);
		clicker.dataset.index = index;
	});
document
	.querySelectorAll(".sandstone-circle-clicker")
	.forEach((clicker, index) => {
		sandstoneClickers.push(clicker);
		clicker.dataset.index = index;
	});
document.querySelectorAll(".coal-circle-clicker").forEach((clicker, index) => {
	coalClickers.push(clicker);
	clicker.dataset.index = index;
});
document
	.querySelectorAll(".silver-circle-clicker")
	.forEach((clicker, index) => {
		silverClickers.push(clicker);
		clicker.dataset.index = index;
	});
document
	.querySelectorAll(".diamond-circle-clicker")
	.forEach((clicker, index) => {
		diamondClickers.push(clicker);
		clicker.dataset.index = index;
	});
document.querySelectorAll(".lapis-circle-clicker").forEach((clicker, index) => {
	lapisClickers.push(clicker);
	clicker.dataset.index = index;
});
document
	.querySelectorAll(".peridot-circle-clicker")
	.forEach((clicker, index) => {
		peridotClickers.push(clicker);
		clicker.dataset.index = index;
	});
document.querySelectorAll(".peridot-score").forEach((scoreDiv, index) => {});
document.querySelectorAll(".topaz-circle-clicker").forEach((clicker, index) => {
	topazClickers.push(clicker);
	clicker.dataset.index = index;
});
document.querySelectorAll(".opal-circle-clicker").forEach((clicker, index) => {
	opalClickers.push(clicker);
	clicker.dataset.index = index;
});
document.querySelectorAll(".amber-circle-clicker").forEach((clicker, index) => {
	amberClickers.push(clicker);
	clicker.dataset.index = index;
});
document
	.querySelectorAll(
		".circle-clicker:not(.oil-circle-clicker):not(.ng-circle-clicker)"
	)
	.forEach((clicker, index) => {
		clicker.dataset.index = index;
	});
// Mapping of row positions to 1-based indices for Dig Sheet A
const rowPositionToIndex = {
	"top: 14.8cqh; left: 5.8cqh;": 1,
	"top: 25.9cqh; left: 5.8cqh;": 2,
	"top: 36.9cqh; left: 5.8cqh;": 3,
	"top: 48.1cqh; left: 5.8cqh;": 4,
	"top: 59.2cqh; left: 5.8cqh;": 5,
	"top: 70.2cqh; left: 5.8cqh;": 6,
	"top: 81.3cqh; left: 5.8cqh;": 7,
	"top: 92.4cqh; left: 5.8cqh;": 8,
	"top: 103.5cqh; left: 5.8cqh;": 9,
	"top: 114.6cqh; left: 5.8cqh;": 10
};

// Mapping of column positions to 1-based indices for Dig Sheet A
const columnPositionToIndex = {
	"top: 84.3cqh; left: 17.0cqh;": 1,
	"top: 84.3cqh; left: 22.5cqh;": 2,
	"top: 84.3cqh; left: 28.1cqh;": 3,
	"top: 84.3cqh; left: 33.6cqh;": 4,
	"top: 84.3cqh; left: 39.1cqh;": 5,
	"top: 84.3cqh; left: 44.7cqh;": 6,
	"top: 84.3cqh; left: 50.2cqh;": 7,
	"top: 84.3cqh; left: 55.8cqh;": 8,
	"top: 84.3cqh; left: 61.3cqh;": 9,
	"top: 84.3cqh; left: 66.9cqh;": 10
};

// Boulder cross-off clickers
document.querySelectorAll(".boulder-cross-off").forEach((clicker, index) => {
	clicker.dataset.index = index;
});

// Row cross-off clickers
document.querySelectorAll(".row-cross-off").forEach((clicker, index) => {
	clicker.dataset.index = index;
});

// Column cross-off clickers
document.querySelectorAll(".column-cross-off").forEach((clicker, index) => {
	clicker.dataset.index = index;
});
document.querySelectorAll(".oil-circle-clicker").forEach((clicker, index) => {
	oilClickers.push(clicker);
	clicker.dataset.index = index;
});
document.querySelectorAll(".ng-circle-clicker").forEach((clicker, index) => {
	ngClickers.push(clicker);
	clicker.dataset.index = index;
});
document
	.querySelectorAll(".oil-ng-cross-off-clicker")
	.forEach((clicker, index) => {
		oilNgCrossOffClickers.push(clicker);
		clicker.dataset.index = index;
		clicker.addEventListener("click", () => {
			if (clicker.classList.contains("crossed-off")) {
				clicker.classList.remove("crossed-off");
				updateOilNgCrossOffClickers();
				playSound("crossOff");
			} else if (canClickOilNgCrossOff(index)) {
				clicker.classList.add("crossed-off");
				updateOilNgCrossOffClickers();
				playSound("crossOff");
			}
		});
	});

const ngCrossoffDivs = [];

document.querySelectorAll(".ng-cross-off").forEach((div, index) => {
    ngCrossoffDivs.push(div);
    div.dataset.index = index;
    div.addEventListener("click", () => {
        if (div.classList.contains("used")) return; // Prevent any toggle if used
        if (div.classList.contains("crossed-off")) {
            div.classList.remove("crossed-off");
            const isClickable =
                gamePhase === "dig" &&
                selectedCells.size === 0 &&
                lockedGroups.length === 0 &&
                index < ngCount &&
                !bonusDigMode;
            div.style.opacity = isClickable ? "1" : "0.5";
            div.style.pointerEvents = isClickable ? "auto" : "none";
            div.classList.toggle("clickable", isClickable);
            playSound("crossOff");
            updateNgCrossoffState();
        } else if (div.classList.contains("clickable")) {
            div.classList.add("crossed-off");
            div.classList.remove("clickable");
            div.style.opacity = "1";
            div.style.pointerEvents = "auto"; // Allow uncrossing
            playSound("crossOff");
            updateNgCrossoffState();
            // Tutorial: On crossing off NG-Crossoff-1 (index 0) at step 17, advance to show message 18
            if (tutorialMode && tutorialStep === 17 && index === 0) {
                advanceTutorialStep();
                console.log("NG-Crossoff-1 crossed off, advanced to step 18");
            }
        }
    });
});

const ngBonusDivs = [];

document.querySelectorAll(".ng-bonus").forEach((div, index) => {
	ngBonusDivs.push(div);
	div.dataset.index = index;
});

document.querySelectorAll(".cross-off-round").forEach((element, index) => {
	roundElements.push(element);
});
const finalScoreDiv = document.getElementById("final-score");
if (finalScoreDiv) {
	finalScoreDiv.addEventListener("click", () => {
		finalScoreDiv.classList.toggle("hidden-score");
		if (!finalScoreDiv.classList.contains("hidden-score")) {
			updateFinalScore();
		} else {
			finalScoreDiv.textContent = "";
		}
	});
}
rowBonusCount = document.querySelectorAll(".row-cross-off.crossed-off").length;
columnBonusCount = document.querySelectorAll(".column-cross-off.crossed-off")
	.length;
boulderBonusCount = document.querySelectorAll(".boulder-cross-off.crossed-off")
	.length;
updateQuartzClickers();
updateSandstoneClickers();
updateCoalClickers();
updateDiamondClickers();
updateSilverClickers();
updateLapisClickers();
updatePeridotClickers();
updateTopazClickers();
updateOpalClickers();
updateAmberClickers();
updateOilClickers();
updateNgClickers();
updateOilNgCrossOffClickers();
updateCellCursors();
stateHistory.push(saveState());
const freePlaySubmenu = document.getElementById("free-play-submenu");
const backButton = document.getElementById("back-button");
const playButton = document.getElementById("play-button");
const randomButton = document.getElementById("random-button");
const digSheetButtons = document.querySelectorAll(
	".dig-sheet-buttons .sheet-button"
);
const rollSheetButtons = document.querySelectorAll(
	".roll-sheet-buttons .sheet-button"
);

let selectedDigSheet = "dig-sheet-a"; // Default to Dig Sheet A
let selectedRollSheet = "roll-sheet-a"; // Default to Roll Sheet A

// Initialize default selections when sub-menu opens
function initializeSubMenuSelections() {
	digSheetButtons.forEach((btn) => {
		if (btn.dataset.digSheet === "dig-sheet-a") {
			btn.classList.add("selected");
		} else {
			btn.classList.remove("selected");
		}
	});
	rollSheetButtons.forEach((btn) => {
		if (btn.dataset.rollSheet === "roll-sheet-a") {
			btn.classList.add("selected");
		} else {
			btn.classList.remove("selected");
		}
	});
	playButton.disabled = false; // Enable Play button by default
}

// Back button to return to main menu
backButton.addEventListener("click", () => {
	freePlaySubmenu.style.display = "none";
	const openingMenu = document.getElementById("opening-menu");
	const mainMenuElements = [
		document.getElementById("free-play-button"),
		document.getElementById("daily-challenge-button"),
		document.getElementById("daily-challenge-timer"),
		document.getElementById("game-logo")
	];
	const resumeButton = document.getElementById("resume-button");
	openingMenu.style.display = "flex";
	mainMenuElements.forEach((el) => {
		if (el) el.style.display = "";
	});
	if (resumeButton)
		resumeButton.style.display = hasGameState() ? "block" : "none";
	// Reset selections to default
	selectedDigSheet = "dig-sheet-a";
	selectedRollSheet = "roll-sheet-a";
	playSound("click");
});

// Dig sheet selection
digSheetButtons.forEach((button) => {
	button.addEventListener("click", () => {
		digSheetButtons.forEach((btn) => btn.classList.remove("selected"));
		button.classList.add("selected");
		selectedDigSheet = button.dataset.digSheet;
		updatePlayButton();
		playSound("click");
	});
});

// Roll sheet selection
rollSheetButtons.forEach((button) => {
	button.addEventListener("click", () => {
		rollSheetButtons.forEach((btn) => btn.classList.remove("selected"));
		button.classList.add("selected");
		selectedRollSheet = button.dataset.rollSheet;
		updatePlayButton();
		playSound("click");
	});
});

// Enable Play button when both sheets are selected
function updatePlayButton() {
	playButton.disabled = !(selectedDigSheet && selectedRollSheet);
}

// Play button to start game with selected sheets
playButton.addEventListener("click", () => {
	if (selectedDigSheet && selectedRollSheet) {
		gameMode = "free-play";
		currentDigSheet = selectedDigSheet;
		currentRollSheet = selectedRollSheet;
		const digSheetElement = document.getElementById("dig-sheet");
		const overlayImg = document.querySelector("#dig-sheet-overlay img");
		const rollSheetImg = document
			.getElementById("roll-sheet")
			.querySelector("img:not(#green-image img):not(#white-image img)");
		const openingMenu = document.getElementById("opening-menu");
		const resumeButton = document.getElementById("resume-button");
		const homeButton = document.getElementById("home-button");
		if (!digSheetElement || !overlayImg || !rollSheetImg || !openingMenu) {
			console.error("Error: Missing game elements", {
				digSheetElement,
				overlayImg,
				rollSheetImg,
				openingMenu
			});
			return;
		}
		console.log("Play clicked, setting sheets:", {
			currentDigSheet,
			currentRollSheet
		});
		digSheetElement.style.backgroundImage = `url(${digSheetBackgroundImages[currentDigSheet]})`;
		overlayImg.src = digSheetOverlayImages[currentDigSheet];
		rollSheetImg.src = rollSheetImages[currentRollSheet];
		// Set default dice images (6 for both green and white)
		greenImage.innerHTML = `<img src="${imageMap[currentRollSheet].green[6]}" alt="Die Image">`;
		whiteImage.innerHTML = `<img src="${imageMap[currentRollSheet].white[6]}" alt="Die Image">`;
		die1.setAttribute("data-value", "6");
		die2.setAttribute("data-value", "6");
		// Update boulder positions
		const boulderElements = document.querySelectorAll(".boulder-cross-off");
		boulderElements.forEach((element, index) => {
			const config = digSheetBoulderConfigs[currentDigSheet][index];
			if (config) {
				element.style.top = config.top;
				element.style.left = config.left;
			}
		});
		// Hide opening menu to reveal game-container (already visible underneath)
		openingMenu.style.display = "none";
		freePlaySubmenu.style.display = "none";
		if (resumeButton) resumeButton.style.display = "block";
		if (homeButton) {
			homeButton.classList.remove("loading");
			homeButton.classList.add("loaded");
		}
		// Force redraw of dig sheet and roll sheet
		requestAnimationFrame(() => {
			digSheetElement.offsetHeight;
			rollSheetImg.offsetHeight;
			console.log("Dig sheet and roll sheet redrawn", {
				digSheetBackground: digSheetElement.style.backgroundImage,
				overlayImage: overlayImg.src,
				rollSheetImage: rollSheetImg.src
			});
		});
		resetGrid();
		playSound("click");
	}
});

// Random button to select random sheets and start game
randomButton.addEventListener("click", () => {
	const digSheetsList = [
		"dig-sheet-a",
		"dig-sheet-b",
		"dig-sheet-c",
		"dig-sheet-d",
		"dig-sheet-e",
		"dig-sheet-f",
		"dig-sheet-g",
		"dig-sheet-h"
	];
	const rollSheetsList = ["roll-sheet-a", "roll-sheet-b"];
	selectedDigSheet =
		digSheetsList[Math.floor(Math.random() * digSheetsList.length)];
	currentDigSheet = selectedDigSheet;
	selectedRollSheet =
		rollSheetsList[Math.floor(Math.random() * rollSheetsList.length)];
	currentRollSheet = selectedRollSheet;
	const digSheetElement = document.getElementById("dig-sheet");
	const overlayImg = document.querySelector("#dig-sheet-overlay img");
	const rollSheetImg = document
		.getElementById("roll-sheet")
		.querySelector("img:not(#green-image img):not(#white-image img)");
	const openingMenu = document.getElementById("opening-menu");
	const resumeButton = document.getElementById("resume-button");
	const homeButton = document.getElementById("home-button");
	if (!digSheetElement || !overlayImg || !rollSheetImg || !openingMenu) {
		console.error("Error: Missing game elements", {
			digSheetElement,
			overlayImg,
			rollSheetImg,
			openingMenu
		});
		return;
	}
	console.log("Random clicked, setting sheets:", {
		currentDigSheet,
		currentRollSheet
	});
	digSheetElement.style.backgroundImage = `url(${digSheetBackgroundImages[currentDigSheet]})`;
	overlayImg.src = digSheetOverlayImages[currentDigSheet];
	rollSheetImg.src = rollSheetImages[currentRollSheet];
	// Set default dice images (6 for both green and white)
	greenImage.innerHTML = `<img src="${imageMap[currentRollSheet].green[6]}" alt="Die Image">`;
	whiteImage.innerHTML = `<img src="${imageMap[currentRollSheet].white[6]}" alt="Die Image">`;
	die1.setAttribute("data-value", "6");
	die2.setAttribute("data-value", "6");
	// Update boulder positions
	const boulderElements = document.querySelectorAll(".boulder-cross-off");
	boulderElements.forEach((element, index) => {
		const config = digSheetBoulderConfigs[currentDigSheet][index];
		if (config) {
			element.style.top = config.top;
			element.style.left = config.left;
		}
	});
	// Hide opening menu to reveal game-container (already visible underneath)
	openingMenu.style.display = "none";
	freePlaySubmenu.style.display = "none";
	if (resumeButton) resumeButton.style.display = "block";
	if (homeButton) {
		homeButton.classList.remove("loading");
		homeButton.classList.add("loaded");
	}
	// Force redraw of dig sheet and roll sheet
	requestAnimationFrame(() => {
		digSheetElement.offsetHeight;
		rollSheetImg.offsetHeight;
		console.log("Dig sheet and roll sheet redrawn", {
			digSheetBackground: digSheetElement.style.backgroundImage,
			overlayImage: overlayImg.src,
			rollSheetImage: rollSheetImg.src
		});
	});
	resetGrid();
	playSound("click");
});


    </script>
</body>
</html>

